<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>蕩漾</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>恍不觉梦,流离之人,追逐幻影,弃友弃人</description>
    <pubDate>Sat, 11 Oct 2025 18:07:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>NFC</title>
      <link>http://example.com/2025/nfc-scheme/</link>
      <guid>http://example.com/2025/nfc-scheme/</guid>
      <pubDate>Wed, 01 Oct 2025 16:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;扫一扫&quot;&gt;&lt;a href=&quot;#扫一扫&quot; class=&quot;headerlink&quot; title=&quot;扫一扫&quot;&gt;&lt;/a&gt;扫一扫&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;应用&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;URL Scheme&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;微信&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;weixin:&amp;#x2F;&amp;#x2F;scanqrcode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支付宝&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;alipays:&amp;#x2F;&amp;#x2F;platformapi&amp;#x2F;startapp?saId&amp;#x3D;10000007&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QQ&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;mqqapi:&amp;#x2F;&amp;#x2F;qrcode&amp;#x2F;scan_qrcode?version&amp;#x3D;1&amp;amp;src_type&amp;#x3D;app&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tim&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;tim:&amp;#x2F;&amp;#x2F;qrcode&amp;#x2F;scan_qrcode?version&amp;#x3D;1&amp;amp;src_type&amp;#x3D;app&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;美团&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;imeituan:&amp;#x2F;&amp;#x2F;&lt;a href=&quot;http://www.meituan.com/scanQRCode?openAR=1&quot;&gt;www.meituan.com/scanQRCode?openAR=1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;京东&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;openapp.jdmobile:&amp;#x2F;&amp;#x2F;virtual?params&amp;#x3D;{“category”:”jump”,”des”:”saoasao”}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;钉钉&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;dingtalk:&amp;#x2F;&amp;#x2F;dingtalkclient&amp;#x2F;page&amp;#x2F;scan&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;淘宝&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;taobao:&amp;#x2F;&amp;#x2F;tb.cn&amp;#x2F;n&amp;#x2F;scancode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;知乎&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;zhihu:&amp;#x2F;&amp;#x2F;codereader&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bilibili&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;bilibili:&amp;#x2F;&amp;#x2F;qrcode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;微博&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;sinaweibo:&amp;#x2F;&amp;#x2F;qrcode&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h2><table><thead><tr><th>应用</th><th align="left">URL Scheme</th></tr></thead><tbody><tr><td>微信</td><td align="left">weixin:&#x2F;&#x2F;scanqrcode</td></tr><tr><td>支付宝</td><td align="left">alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?saId&#x3D;10000007</td></tr><tr><td>QQ</td><td align="left">mqqapi:&#x2F;&#x2F;qrcode&#x2F;scan_qrcode?version&#x3D;1&amp;src_type&#x3D;app</td></tr><tr><td>Tim</td><td align="left">tim:&#x2F;&#x2F;qrcode&#x2F;scan_qrcode?version&#x3D;1&amp;src_type&#x3D;app</td></tr><tr><td>美团</td><td align="left">imeituan:&#x2F;&#x2F;<a href="http://www.meituan.com/scanQRCode?openAR=1">www.meituan.com/scanQRCode?openAR=1</a></td></tr><tr><td>京东</td><td align="left">openapp.jdmobile:&#x2F;&#x2F;virtual?params&#x3D;{“category”:”jump”,”des”:”saoasao”}</td></tr><tr><td>钉钉</td><td align="left">dingtalk:&#x2F;&#x2F;dingtalkclient&#x2F;page&#x2F;scan</td></tr><tr><td>淘宝</td><td align="left">taobao:&#x2F;&#x2F;tb.cn&#x2F;n&#x2F;scancode</td></tr><tr><td>知乎</td><td align="left">zhihu:&#x2F;&#x2F;codereader</td></tr><tr><td>bilibili</td><td align="left">bilibili:&#x2F;&#x2F;qrcode</td></tr><tr><td>微博</td><td align="left">sinaweibo:&#x2F;&#x2F;qrcode</td></tr></tbody></table><span id="more"></span><h2 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h2><ul><li>bilibili:&#x2F;&#x2F;video&#x2F;【bv号】 打开哔哩哔哩并播放视频</li><li>bilibili:&#x2F;&#x2F;space&#x2F;【Uid】 打开用户主页</li><li>bilibili:&#x2F;&#x2F;live&#x2F;【直播间ID】 打开直播间</li></ul><h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2><ul><li>orpheus:&#x2F;&#x2F;song&#x2F;【歌曲ID】</li><li>本地音乐 orpheus:&#x2F;&#x2F;download</li><li>orpheus:&#x2F;&#x2F;playlist&#x2F;【歌单ID】</li></ul><h2 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h2><ul><li>qqmusic:&#x2F;&#x2F;qq.com&#x2F;media&#x2F;playSonglist?p&#x3D;{“song”:[{“songmid”:”歌曲ID”}]}</li></ul><h2 id="抖音"><a href="#抖音" class="headerlink" title="抖音"></a>抖音</h2><ul><li><p>snssdk1128:&#x2F;&#x2F;aweme&#x2F;detail&#x2F;{itemId}作品</p></li><li><p>snssdk1128:&#x2F;&#x2F;aweme&#x2F;live&#x2F;{roomId}直播</p></li></ul><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><ul><li>扫一扫 weixin:&#x2F;&#x2F;scanqrcode</li><li>扫一扫 weixin:&#x2F;&#x2F;dl&#x2F;scan</li><li>微信付款码 weixin:&#x2F;&#x2F;widget&#x2F;pay</li><li>反馈 weixin:&#x2F;&#x2F;dl&#x2F;feedback</li><li>朋友圈 weixin:&#x2F;&#x2F;dl&#x2F;moments</li><li>设置 weixin:&#x2F;&#x2F;dl&#x2F;settings</li><li>消息通知设置 weixin:&#x2F;&#x2F;dl&#x2F;notifications</li><li>聊天设置 weixin:&#x2F;&#x2F;dl&#x2F;chat</li><li>通用设置 weixin:&#x2F;&#x2F;dl&#x2F;general</li><li>公众号 weixin:&#x2F;&#x2F;dl&#x2F;officialaccounts</li><li>游戏 weixin:&#x2F;&#x2F;dl&#x2F;games</li><li>帮助 weixin:&#x2F;&#x2F;dl&#x2F;help</li><li>反馈 weixin:&#x2F;&#x2F;dl&#x2F;feedback</li><li>个人信息 weixin:&#x2F;&#x2F;dl&#x2F;profile</li><li>功能插件 weixin:&#x2F;&#x2F;dl&#x2F;features</li></ul><h2 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h2><ul><li>扫一扫 alipayqr:&#x2F;&#x2F;platformapi&#x2F;startapp?saId&#x3D;10000007</li><li>付款码 alipayqr:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000056</li><li>收款码 alipayqr:&#x2F;&#x2F;platformapi&#x2F;startapp?saId&#x3D;20000123</li><li>转账 alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000116</li><li>发红包 alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?saId&#x3D;88886666</li><li>记账本 alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000168</li><li>创建群聊 alipay:&#x2F;&#x2F;platformapi&#x2F;startapp？appId&#x3D;20000254&amp;actionType&#x3D;createGroup</li><li>滴滴出行 alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000778</li><li>蚂蚁森林 alipay:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;60000002</li><li>手机充值 alipayqr:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;10000003</li><li>生活缴费 alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000193</li><li>快递查询 alipays:&#x2F;&#x2F;platformapi&#x2F;startapp?appId&#x3D;20000754</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <category domain="http://example.com/tags/NFC/">NFC</category>
      
      
      <comments>http://example.com/2025/nfc-scheme/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Juri连段备忘录</title>
      <link>http://example.com/2025/han-zhu-li-lian-duan-bei-wang-lu/</link>
      <guid>http://example.com/2025/han-zhu-li-lian-duan-bei-wang-lu/</guid>
      <pubDate>Tue, 17 Jun 2025 16:00:00 GMT</pubDate>
      
      <description>&lt;img src=&quot;https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/QQ%25E5%259B%25BE%25E7%2589%258720250803223557(1).jpeg&quot; style=&quot;zoom:33%;&quot; /&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/QQ%25E5%259B%25BE%25E7%2589%258720250803223557(1).jpeg" style="zoom:33%;" /><span id="more"></span><h2 id="进攻压制"><a href="#进攻压制" class="headerlink" title="进攻压制"></a>进攻压制</h2><h3 id="贴身轻拳"><a href="#贴身轻拳" class="headerlink" title="贴身轻拳"></a>贴身轻拳</h3><ul><li><p>“轻拳<em>2”+轻拳+重升龙【+28】 —— 两点确认，最速抢招</em></p><ul><li><em>被防：“轻拳</em>2”+轻脚+中风破刃 —— 被防基本无责，但轻脚会被对手6帧拳脚抢招</li></ul></li></ul><h3 id="贴身轻脚"><a href="#贴身轻脚" class="headerlink" title="贴身轻脚"></a>贴身轻脚</h3><ul><li>“下轻脚+下轻拳*2+中风破刃”【+37】 —— 无脑复合，偷下段<ul><li>被防：基本无责</li></ul></li></ul><h3 id="近距离"><a href="#近距离" class="headerlink" title="近距离"></a>近距离</h3><ul><li>“轻拳+轻脚”+重升龙【+26~28】 —— 两点确认，距离要求宽松，非常推荐</li></ul><h3 id="中远距离"><a href="#中远距离" class="headerlink" title="中远距离"></a>中远距离</h3><ul><li><p>“下中脚+中风破刃”【+37】 —— 无脑复合，全游最长可取消的下段拳脚，好用多用。</p><ul><li>被防：控制好距离基本无责</li></ul></li><li><p>“下中脚+绿冲取消中拳”+下重拳+重风破刃+重升龙【+27】 —— 两点确认</p><ul><li>被防：“下中脚+绿冲取消中拳”+中拳+下中拳+中风破刃</li></ul></li></ul><h3 id="较远距离"><a href="#较远距离" class="headerlink" title="较远距离"></a>较远距离</h3><ul><li><p>“绿冲中拳+下重拳”+重风破刃+重升龙【+28】 —— 两点确认，蛛俐招牌绿冲</p><ul><li>被防：“绿冲中拳+下重拳”+轻风破刃</li></ul></li><li><p>“绿冲下轻脚+中拳+下中拳+中风破刃”【+37】 —— 无脑复合，偷下段</p></li></ul><h3 id="远距离"><a href="#远距离" class="headerlink" title="远距离"></a>远距离</h3><ul><li><p>“绿冲前中拳”+下重拳+重风破刃+重升龙【+28】 —— 绿冲前中拳确认</p><ul><li>被防：“绿冲前中拳”+下轻拳+轻风破刃</li></ul></li><li><p>“绿冲下中脚+绿冲取消中拳”+任意收尾 —— 两点确认，耗四格斗气，斩杀用</p><ul><li>被防：“绿冲下中脚+绿冲取消中拳”+中拳+下中拳+中风破刃</li></ul></li></ul><h3 id="跳入"><a href="#跳入" class="headerlink" title="跳入"></a>跳入</h3><ul><li><p>近距离~较远距离：</p><ul><li>0球：“跳中脚+中拳+下中拳”+中风破刃【+37】 —— 三点确认<ul><li>压起身方式同贴身轻脚连段</li></ul></li></ul></li><li><p>近距离~较远距离：</p><ul><li>2球：“跳中脚+中拳+下中拳”+五黄杀+地波【+19】 —— 三点确认，压起身和伤害比上一套更猛<ul><li>压起身：<ul><li>前前卡帧+中拳 <ul><li>对手如果原地受身，则地波先击中，按照常规中拳贴身压制方式处理</li><li>对手如果后退受身，则中拳先击中，地波命中+13，接重拳+重风破刃+重升龙<ul><li>地波被防+9，接后重脚+中风破刃，磨掉对手一格多斗气</li></ul></li></ul></li></ul></li><li>微前走确认对手前后起手，后起身前前踩头</li></ul></li></ul></li><li><p>远距离，0球：“跳重脚+前中拳+轻风破刃”【+37】 —— 无脑复合</p></li><li><p>远距离，1球：“跳重脚+重拳”+下劈+前中拳+重升龙&#x2F;中风破刃【+28&#x2F;+37】 —— 两点确认</p><ul><li>被防：“跳重脚+重拳”+地波</li></ul></li></ul><h2 id="中拳-下中拳被防处理"><a href="#中拳-下中拳被防处理" class="headerlink" title="中拳+下中拳被防处理"></a>中拳+下中拳被防处理</h2><ul><li><p>中拳之后：</p><ul><li><p>蹲防：前跳踩头</p></li><li><p>后走：下中脚</p></li><li><p>轻攻击：站重拳差和</p></li></ul></li><li><p>0球 —— 没什么可接的，满斗气可以接绿冲取消中拳，不太划算</p><ul><li>版边可以后后，距离刚好升龙对空</li></ul></li><li><p>1球，版边限定 —— 接地波+前中拳复合轻风破刃，对手如果用中力度拳脚抢招就会被打康吃一套</p><ul><li>对手如果用轻力度拳脚抢招或一直拉防就被磨掉一格多斗气，而蛛俐不耗任何资源还不会被确反</li><li>想迸放吗</li><li>不过前跳，斗反和凹都能破解，所以要和后后混着用</li></ul></li><li><p>2球，版中限定 —— 接回旋踢+地波，回旋踢能打乱动，被防-3</p><ul><li>压起身：<ul><li>微前走确认对手前后起手，后起身前前踩头</li><li>前前卡帧+中拳 <ul><li>对手如果原地受身，则地波先击中，按照常规中拳贴身压制方式处理</li><li>对手如果后退受身，则中拳先击中，地波命中+13，接重拳+重风破刃+重升龙<ul><li>地波被防+9，接后重脚+中风破刃，磨掉对手一格多斗气</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="压起身"><a href="#压起身" class="headerlink" title="压起身"></a>压起身</h2><h3 id="重升龙【-26-28】"><a href="#重升龙【-26-28】" class="headerlink" title="重升龙【+26~28】"></a>重升龙【+26~28】</h3><h4 id="劈头-轻脚重升龙【-26】"><a href="#劈头-轻脚重升龙【-26】" class="headerlink" title="劈头+轻脚重升龙【+26】"></a>劈头+轻脚重升龙【+26】</h4><ul><li><p>前前卡帧+下中脚复合轻&#x2F;中风破刃 </p><p>a.对手原地受身用轻风破刃</p><p>b.对手后退受身用中风破刃</p></li><li><p>前前卡帧+中拳 （不偷帧）</p></li><li><p>绿冲放帧中拳【+6】</p></li><li><p>版边限定：中拳卡帧之后【+4】不可防斗反</p></li></ul><h4 id="重风破刃-重升龙【-27】"><a href="#重风破刃-重升龙【-27】" class="headerlink" title="重风破刃+重升龙【+27】"></a>重风破刃+重升龙【+27】</h4><ul><li><p>前前卡帧+下中脚复合轻&#x2F;中风破刃 </p><p>a.对手原地受身用轻风破刃</p><p>b.对手后退受身用中风破刃</p></li><li><p>前前卡帧+中拳 </p><ul><li>偷帧命中+8，被防+3，均接下中拳，版边限定不怕斗反</li></ul></li><li><p>绿冲放帧中拳【+6】</p></li><li><p>版边限定：中拳卡帧之后【+5】可防斗反</p></li></ul><h4 id="轻攻击-重升龙【-28】"><a href="#轻攻击-重升龙【-28】" class="headerlink" title="轻攻击+重升龙【+28】"></a>轻攻击+重升龙【+28】</h4><ul><li><p>前前卡帧+中拳 （不偷帧）</p></li><li><p>前前卡帧+下中脚复合轻&#x2F;中风破刃 </p><p>a.对手原地受身用轻风破刃</p><p>b.对手后退受身用中风破刃</p></li><li><p>板边不能中拳卡帧</p></li><li><p>版边限定：中拳卡帧之后【+6】可防斗反</p></li></ul><h3 id="中风破刃【-37】"><a href="#中风破刃【-37】" class="headerlink" title="中风破刃【+37】"></a>中风破刃【+37】</h3><ul><li>前前卡帧+前重拳复合轻风破刃 —— 较为安全的压起身，被防只有个别4帧拳脚很长的角色能确反（卢克 玛丽莎 曼侬 本田 拉希德）</li><li>下中脚卡帧【+8】可后走打拆，仿帧投</li><li>前前卡帧+前重拳复合轻地波 —— 命中接下劈，2球限定，被防-3</li><li>前前卡帧+绿冲中拳 —— 命中+11，被防+6，均接下重拳</li><li>前前卡帧+绿冲下轻脚 —— 命中+7，接中拳，被防+3，可接中拳&#x2F;投</li><li>其实最推荐直接绿冲凭感觉压起身，可以及时后走骗拆防凹</li><li>轻风破刃卡帧+中拳复合轻风破刃 —— 被防无责，最速攒满3球，开始无限压制，版边限定</li><li>绿冲+迸放 —— 版边限定</li></ul><h3 id="五黄杀"><a href="#五黄杀" class="headerlink" title="五黄杀"></a>五黄杀</h3><h4 id="有球结尾【-37】"><a href="#有球结尾【-37】" class="headerlink" title="有球结尾【+37】"></a>有球结尾【+37】</h4><p>参考中风破结尾</p><ul><li>五黄杀+地波压制<ul><li>微前走确认对手前后起手，后起身前前踩头</li><li>前前卡帧+中拳 <ul><li>对手如果原地受身，则地波先击中，按照常规中拳贴身压制方式处理</li><li>对手如果后退受身，则中拳先击中，地波命中+13，接重拳+重风破刃+重升龙<ul><li>地波被防+9，接后重脚+中风破刃，磨掉对手一格多斗气</li></ul></li></ul></li></ul></li></ul><h4 id="无球结尾【-27】"><a href="#无球结尾【-27】" class="headerlink" title="无球结尾【+27】"></a>无球结尾【+27】</h4><ul><li><p>前前卡帧+下中脚复合轻&#x2F;中风破刃 </p><p>a.对手原地受身用轻风破刃</p><p>b.对手后退受身用中风破刃</p></li><li><p>前前卡帧+中拳 </p><ul><li>偷帧命中+8，被防+3，均接下中拳，版边限定不怕斗反</li></ul></li><li><p>绿冲放帧中拳【+6】</p></li><li><p>版边限定：中拳卡帧之后【+5】可防斗反</p></li></ul><h3 id="重风破刃-轻升龙收尾【-36】"><a href="#重风破刃-轻升龙收尾【-36】" class="headerlink" title="重风破刃+轻升龙收尾【+36】"></a>重风破刃+轻升龙收尾【+36】</h3><ul><li>轻风破刃卡帧+中拳复合轻风破刃 —— 被防无责，最速攒满3球，开始无限压制，版边限定</li><li>其实最推荐直接绿冲凭感觉压起身，可以及时后走骗拆防凹</li></ul><h3 id="一气【-48】"><a href="#一气【-48】" class="headerlink" title="一气【+48】"></a>一气【+48】</h3><h4 id="裸一气"><a href="#裸一气" class="headerlink" title="裸一气"></a>裸一气</h4><ul><li>远版【+48】：</li><li>版边【+26】</li></ul><h4 id="重风破刃-一气"><a href="#重风破刃-一气" class="headerlink" title="重风破刃+一气"></a>重风破刃+一气</h4><ul><li>远版【+53】</li><li>版边【+20】</li></ul><h4 id="OD回旋踢下劈-一气收尾"><a href="#OD回旋踢下劈-一气收尾" class="headerlink" title="OD回旋踢下劈+一气收尾"></a>OD回旋踢下劈+一气收尾</h4><ul><li>远版【+51】 </li><li>版边【+27】</li></ul><h3 id="前投【-25】"><a href="#前投【-25】" class="headerlink" title="前投【+25】"></a>前投【+25】</h3><ul><li><p>版中除非投到确反康否则无法压起身，蓄球吧</p></li><li><p>绿冲前中拳</p></li><li><p>前前卡帧 【 +3】下轻脚&#x2F;中拳&#x2F;投&#x2F;后后骗拆，版边限定</p></li></ul><h4 id="后投【-18】"><a href="#后投【-18】" class="headerlink" title="后投【+18】"></a>后投【+18】</h4><ul><li>绿冲前中拳压起身，版中确反康或版边限定</li></ul><h2 id="确反"><a href="#确反" class="headerlink" title="确反"></a>确反</h2><h3 id="无风破球"><a href="#无风破球" class="headerlink" title="无风破球"></a>无风破球</h3><ul><li><p>无资源时：中拳+重拳+下劈+轻脚+重升龙【+26】 —— 不太推荐，0球时还是蓄球优先</p><ul><li>压起身：除了近距离连段那些压起身，+26刚好可以直接迸</li></ul></li><li><p>蓄球：中拳+重拳+重风破刃+重升龙【+27】</p></li><li><p>最推荐：中拳+重拳+OD劈头+前中拳+中风破&#x2F;重升龙</p></li></ul><h3 id="1风破球"><a href="#1风破球" class="headerlink" title="1风破球"></a>1风破球</h3><ul><li>打伤害：中拳+重拳+下劈+前中拳+重升龙【+28】 —— 要蓄球就把重升龙换成中风破刃</li></ul><h3 id="2风破球"><a href="#2风破球" class="headerlink" title="2风破球"></a>2风破球</h3><ul><li>打伤害：前重拳+下中拳+地波下劈+前中拳+重升龙【+28】 —— 要蓄球就把重升龙换成中风破刃</li><li>资源回收：中拳+重拳+OD劈头+前中拳+地波_劈头+前中拳+中风破&#x2F;重升龙</li></ul><h3 id="3风破球"><a href="#3风破球" class="headerlink" title="3风破球"></a>3风破球</h3><ul><li><p>打伤害：前重拳+下中拳+回旋踢地波下劈+前中拳+重升龙【+28】 —— 要蓄球就把重升龙换成中风破刃</p></li><li><p>中拳+重拳+回旋踢-地波-下劈+前中拳+中风破&#x2F;重升龙</p></li><li><p>版边，3斗气，1球，打伤害：前重拳+下中拳+OD回旋踢下劈+重升龙【+27】 —— 性价比极高的连段，推板距离优秀，重升龙还能换成一气</p></li></ul><h3 id="反迸非版边"><a href="#反迸非版边" class="headerlink" title="反迸非版边"></a>反迸非版边</h3><ul><li>打伤害：前重拳+下中拳+回旋踢地波下劈+前中拳+重升龙【+28】 —— 要蓄球就把重升龙换成中风破刃</li></ul><h3 id="反迸版边"><a href="#反迸版边" class="headerlink" title="反迸版边"></a>反迸版边</h3><ul><li><p>绿冲前重拳+重风破刃+轻风破刃+中升龙【+30】 —— 能蓄2球</p><p>压起身：</p><ul><li>版边像这种风破刃+重升龙收尾的连段可以改为风破刃+中升龙收尾，伤害不变，有利帧+30<ul><li>前前卡帧+下中拳 —— 偷帧命中+8，接下重拳</li><li>被防+1，接下中拳+中风破刃</li></ul></li><li>绿冲前中脚</li></ul></li><li><p>前前+下重拳+轻风破刃+重升龙【+30】 —— 能蓄1球，伤害比上一套高，压起身同上</p></li></ul><h3 id="墙崩"><a href="#墙崩" class="headerlink" title="墙崩"></a>墙崩</h3><p>参考反迸版边连段，但第一套不再适用</p><h3 id="晕连"><a href="#晕连" class="headerlink" title="晕连"></a>晕连</h3><p>后跳+轻风破刃+前跳重脚+下重拳+任意收尾</p><h2 id="打拆投"><a href="#打拆投" class="headerlink" title="打拆投"></a>打拆投</h2><h3 id="晃拆"><a href="#晃拆" class="headerlink" title="晃拆"></a>晃拆</h3><h4 id="下重脚"><a href="#下重脚" class="headerlink" title="下重脚"></a>下重脚</h4><ul><li>前中拳卡帧，后走打拆</li></ul><h4 id="中风破刃结尾"><a href="#中风破刃结尾" class="headerlink" title="中风破刃结尾"></a>中风破刃结尾</h4><ul><li>下中脚卡帧</li><li>下重拳卡帧，可后走打拆</li></ul><h4 id="中升龙（-31"><a href="#中升龙（-31" class="headerlink" title="中升龙（+31)"></a>中升龙（+31)</h4><ul><li>前中拳中拳偷帧</li><li>前中拳卡帧后走打拆</li></ul><h4 id="重升龙（-28）"><a href="#重升龙（-28）" class="headerlink" title="重升龙（+28）"></a>重升龙（+28）</h4><ul><li>中拳偷帧</li><li>放帧重升龙，肘击卡帧后走打拆</li></ul><h4 id="跳重拳踩头"><a href="#跳重拳踩头" class="headerlink" title="跳重拳踩头"></a>跳重拳踩头</h4><ul><li>肘击卡帧后走打拆</li></ul><h3 id="0风破球"><a href="#0风破球" class="headerlink" title="0风破球"></a>0风破球</h3><ul><li>“重拳+OD地波”+重升龙【+27】 —— 两点确认<ul><li>被防：“重拳+OD地波”+前中拳+轻风破刃</li></ul></li></ul><h3 id="1风破球-1"><a href="#1风破球-1" class="headerlink" title="1风破球"></a>1风破球</h3><ul><li><p>“重拳+地波”+下中拳+中风破刃【+37】 —— 两点确认</p><ul><li>被防：“重拳+地波”+前中拳+轻风破刃</li></ul></li><li><p>1球，3斗气 “重拳+OD回旋踢”+下劈+重升龙【+27】 —— 两点确认，非版边的话，回旋踢只踢两下就出下劈</p><ul><li>被防：“重拳+OD回旋踢”+地波 —— 全程联防，对手没得凹</li></ul></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>重脚确反康+重升龙【+26~27】 —— 重脚最远端命中接不上重升龙</p></li><li><p>下重脚确反康，下重拳卡帧</p></li></ul><h2 id="风水引擎相关"><a href="#风水引擎相关" class="headerlink" title="风水引擎相关"></a>风水引擎相关</h2><ul><li><p>起手①：前重拳开风水 —— 在对手斗气少于2格时，不需确认是否命中直接开，对手要么斗反气绝，要么承受无尽的择</p></li><li><p>起手②：中拳+下中拳开风水 —— 有充足的时间确认命中再开</p></li></ul><p>连段组件①：下轻拳+下中脚+中拳 —— 通常破防用的组件</p><p>连段组件②：轻脚+前中拳+下中脚 —— 使用率最高的组件</p><p>连段组件③：下重拳+重脚+重风破刃 —— 变化最丰富的组件</p><p>三个连段组件的衔接必须练熟，可以把风破球和风水引擎调成无限，在训练场这样练习</p><p>起手命中：</p><p>清斗气：前冲+中脚+中拳+下重拳+迸放【+32】 —— 能打掉近两格斗气</p><p>└压起身：1. 绿冲前中脚+组件②+组件③ —— 中段择</p><ol start="2"><li>下中拳卡帧+下中脚+中拳+组件②+组件③ —— 下段择，版边限定</li></ol><p>无球：前重拳+下劈+组件②+组件③ —— 性价比极高的连段，不易掉招，有安全跳，可以蓄球，还回斗气，只是推板能力略有不足</p><p>有球：前重拳+下劈+下中脚+中拳+组件②+组件③ —— 上一套的升级版</p><p>版中安全跳压起身：“跳中脚+重拳”+绿冲取消下重拳+中脚+中拳+组件②+组件③ —— 两点确认</p><p>└被防：“跳中脚+重拳”+绿冲取消中拳+下中脚+中拳+破防套路 —— 破防套路下面介绍</p><p>版边安全跳压起身：“跳重脚+下中脚+中拳”+组件②+组件③ —— 三点确认，和版中安全跳相比，不需要耗斗气绿冲取消</p><p>起手被防：</p><p>破防套路①：前冲+组件①+组件②+下重脚+轻风破刃 —— 蓄球，被防无责</p><p>└压起身：1. 下轻拳卡帧+下中脚+中拳+组件②+组件③</p><ol start="2"><li>迸放 —— 版边限定</li></ol><p>破防套路②：前冲+组件①+轻脚+前中拳+前中脚+轻风破刃 —— 蓄球，被防无责，加入中段破防能力出众</p><p>└压起身：1. 绿冲下轻脚+下中脚+中拳+组件②+组件③</p><ol start="2"><li>去掉轻风破刃，迸放 —— 版边限定</li></ol><p>破防套路③：前冲+组件①+组件②+绿冲取消前中脚+中脚+中拳+组件②+组件③ —— 耗3格斗气，前中脚会被对手抢招（真有人敢和风水引擎抢招吗）</p><p>被斗反后重新进攻：</p><ol><li><p>绿冲下轻脚&#x2F;下中脚+中拳+组件②+组件③ —— 如果被防就用上面的破防套路</p></li><li><p>跳中拳+跳中脚+下中脚+中拳+组件②+组件③ —— 蛛俐专属中段二连，用跳重拳+跳重脚也可以，不过跳重拳不小心命中就没后续了</p></li></ol><h2 id="斩杀"><a href="#斩杀" class="headerlink" title="斩杀"></a>斩杀</h2><ul><li><p>一气：绿冲前重拳+下重拳+绿冲取消前重拳+中拳+绿冲取消下重拳+中拳tc+一气</p></li><li><p>二气</p><ul><li><p>0~1球：前重拳+二气+前重拳+绿冲取消前重拳+中拳+绿冲取消下重拳+中脚+中拳+组件②+组件③+强化一气&#x2F;重升龙</p></li><li><p>2球：前重拳+二气+前重拳+绿冲取消前重拳+中拳+绿冲取消下重拳+中脚+中拳+组件②+地波下劈+组件②+组件③+强化一气&#x2F;重升龙 —— 如果在版边，可以在下劈后加上下中脚+中拳</p></li><li><p>3球：前重拳+二气+前重拳+绿冲取消前重拳+中拳+绿冲取消下重拳+中脚+中拳+组件②+回旋踢地波下劈+组件②+组件③+强化一气&#x2F;重升龙 —— 如果在版边，可以在下劈和组件②之间加上下中脚+中拳</p></li></ul></li><li><p>三气：绿冲前重拳+下重拳+绿冲取消前重拳+中拳+绿冲取消下重拳+中拳+根据风破球选择连段+三气 6752</p></li></ul><h2 id="角色对策"><a href="#角色对策" class="headerlink" title="角色对策"></a>角色对策</h2><h3 id="老桑"><a href="#老桑" class="headerlink" title="老桑"></a>老桑</h3><h3 id="豪鬼"><a href="#豪鬼" class="headerlink" title="豪鬼"></a>豪鬼</h3><p>1.板边不使用拆投</p><p>2.打白之后尽量往板边推</p><p>3.白了之后少跳，多前走魔血</p><h2 id="虚损压制"><a href="#虚损压制" class="headerlink" title="虚损压制"></a>虚损压制</h2><ul><li>中拳-下中拳-轻反摇腿<ul><li>站中脚复合重反摇：打8帧抢招</li><li>下重脚退远打下段，无法确反</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Game/">Game</category>
      
      
      <category domain="http://example.com/tags/Game/">Game</category>
      
      <category domain="http://example.com/tags/%E8%A1%97%E9%9C%B86/">街霸6</category>
      
      
      <comments>http://example.com/2025/han-zhu-li-lian-duan-bei-wang-lu/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>摄影三要素</title>
      <link>http://example.com/2025/she-ying/</link>
      <guid>http://example.com/2025/she-ying/</guid>
      <pubDate>Wed, 30 Apr 2025 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;曝光三要素&lt;/strong&gt;指的是光圈大小、快门速度、感光度ISO&lt;/p&gt;
&lt;img src=&quot;https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/IMG_20250602_191323.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>曝光三要素</strong>指的是光圈大小、快门速度、感光度ISO</p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/IMG_20250602_191323.jpg" style="zoom: 50%;" /><span id="more"></span><h2 id="1-光圈"><a href="#1-光圈" class="headerlink" title="1.光圈"></a><strong>1.光圈</strong></h2><p>光圈是一个用来控制光线透过镜头，进入机身内感光面光量的装置，它通常是在镜头内。表达光圈大小我们是用f值。完整的光圈值系列如下：</p><p><strong>光圈的两个作用</strong></p><p>1.通过进光量的多少来控制摄影时的曝光程度</p><p>2.通过改变光圈的大小来调节所拍照片的清晰与虚化效果</p><hr><p>此处加入一个摄影术语–<strong>景深</strong></p><p><strong>景深</strong> 通俗地说，景深是指拍摄的照片中，对焦点前后能够看到的清晰对象的范围。景深以深浅来衡量，清晰景物的范围较大，是指景深较深，清晰景物的范围较小，是指景深较浅。</p><p>决定景深的因素–<strong>光圈 焦距 物距</strong></p><p><strong>焦距</strong>是焦点到面镜的中心点之间的距离</p><p><strong>物距</strong>是指拍摄者与拍摄对象的距离，更为精确的说是相机镜头与对焦位置的距离</p><p><strong>光圈 焦距 物距对于景深的影响</strong>可以用以下三句话来概括</p><p>光圈越大，景深越浅；光圈越小，景深越深</p><p>焦距越大，景深越浅；焦距越小；景深越深</p><p>物距越大，景深越深；物距越小，景深越浅</p><p><strong>对于任意光圈，其焦点之后的景深大约是焦点前面景深的2倍</strong></p><hr><h2 id="2-快门"><a href="#2-快门" class="headerlink" title="2.快门"></a><strong>2.快门</strong></h2><p>快门是一种让光线在一段精确的时间里照射胶片或影像传感器的装置。快门的另一种含义是指相机的曝光时间长短，通常称为快门时间</p><p><strong>快门级数</strong></p><p>常见的快门时间有：15 8 4 2 1 1&#x2F;2 1&#x2F;4 1&#x2F;8 1&#x2F;15 1&#x2F;30 1&#x2F;60 1&#x2F;125 1&#x2F;250 1&#x2F;500 1&#x2F;1000 1&#x2F;2000 1&#x2F;4000</p><p><strong>安全快门</strong>：安全快门就是手持相机拍摄时，快门时间的设定不能大于拍摄时焦距的倒数</p><p><strong>常用参数</strong>：行人：1&#x2F;500    静物：1&#x2F;124</p><p><strong>快门速度的选择</strong></p><p>快门可以控制曝光量（画面明暗）和运动物体的动感与静态凝结状态在控制曝光量这方面，主要针对光线条件比较极端的拍摄环境，如夜晚，晨昏这一类光线较暗的环境，需要使用慢速快门进行长时间曝光，以获得合理的曝光量，而在室外的太阳光下，环境光线很亮，就需要使用高速快门，以防止画面过曝，拍摄运动对象时，一般创作手法有两种，通过使用高速快门，可以捕捉运动主体瞬间的静态画面，而使用慢速快门，则可以表现出一种运动模糊的效果，最常见的例子就是使用长时间快门拍摄小溪流水，能够排出水流的轨迹。</p><h2 id="3-感光度ISO"><a href="#3-感光度ISO" class="headerlink" title="3.感光度ISO"></a><strong>3.感光度ISO</strong></h2><p>ISO感光度是摄影领域最常使用的术语之一，在胶片时代，其表示胶卷对光线的敏感度。感光度分为100 200 400等。在光线昏暗的场所拍摄，需要用到高感光，同时色彩的鲜艳度和真实性则越会受到影响。</p><p><img src="https://pica.zhimg.com/v2-55b3525056aba13fdfe0c073894077c8_1440w.jpg" alt="img"></p><p><strong>ISO感光度与画质的关系</strong></p><p>感光度越高，噪点越明显，画质就越粗糙，感光度越小，画质越细腻.</p><h2 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h2><p><strong>相同点</strong>–都可以调节曝光的明暗度，光圈大就亮，ISO高也亮，快门速度慢也亮，相反就是暗。</p><p><strong>不同点</strong></p><ol><li>光圈还可以调节景深，小光圈景深大，大光圈景深小，景深无法通过ISO &#x2F;快门来控制，这就是光圈和ISO &#x2F;快门的区别</li><li>ISO除了明暗调节还有一个特点是降低画质，ISO高了画质就会降低，所以升高ISO在三要素里是最后考虑的，实在不成才提高ISO，当然有个别艺术创作想诚心要那种高噪点低画质而提高ISO是例外。</li><li>快门除了变化曝光明暗还有一个功能就是设定捕获瞬间的长短，慢速快门得到一个动态的模糊的目标，快速快门得到一个凝固的瞬间的目标.</li></ol><h1 id="摄影构图"><a href="#摄影构图" class="headerlink" title="摄影构图"></a>摄影构图</h1><p><strong>构图元素及表现手法</strong></p><p>摄影构图是指在摄影中通过被摄画面中点线面的组合，将景物更为合理 更为优美的表现出来。接触摄影构图，首先要了解一些具体的概念，如主体，陪体，留白，前景，背景等。其中主体是所有元素中最为重要的，一般情况下，主体要处于画面中最显眼的位置，陪体也称为宾体，主要用于修饰 陪衬主体，留白主要是指在画面中留出一定没有景物的区域，给欣赏者留下思索的空间。前景主要用于放在主体等景物之前，起到一个过渡性的作用，使主体不至于太突兀，背景主要用于交代主体所处的环境 时节 时间等信息 也可以起到衬托主体的作用</p><h2 id="景别"><a href="#景别" class="headerlink" title="景别"></a><strong>景别</strong></h2><p>景别的划分大致有两种方法：</p><p>第一 根据被摄取主体（景物）在画幅中所占的画幅面积比例大小为标准.</p><p>第二 是以人物为参照系。即以人物在画面中占据比例的大小来划分景别.</p><p><img src="https://pic2.zhimg.com/v2-649ac77bea925e77aac147ab41ce0eb1_1440w.jpg" alt="img"></p><p>摄影的景别来分可分成远景、全景、中景、近景、特写.这是根据摄影机与被摄对象的距离或是摄成的画面的范围大小来区分的.</p><p>1.<strong>远景</strong>是指拍摄远距离景物和人物的一种广阔的画面.</p><p>2.<strong>全景</strong>是摄取较完整的人和场景的全部.</p><p>3.<strong>中景</strong>一般指摄取人的大半身显得空间较大而又能展示人物间的相互关系在影视中运用较多.</p><p>4.<strong>近景</strong>相对来说视距比中景更近一些了.一般指摄取人物的上半身或景物的局部范围比较强调人物的面部表情、手势和上半身形体动作对塑造人物起到重要作用.</p><p>5.<strong>特写</strong>是指拍摄人的头部、面部、人体的局部、物景的某一部的镜头.这是影视中强调某一局部和细节的一种独特而有效的摄影手段.</p><h2 id="摄影色彩"><a href="#摄影色彩" class="headerlink" title="摄影色彩"></a>摄影色彩</h2><p>摄影学中，色彩的运用是一门重要的学问。利用色彩，可以传达不同的画面情感。自然界中任何色彩的产生都离不开太阳光线红、橙、黄、绿、青、蓝、紫这7种光谱色彩的混合叠加。人们把红、绿、蓝这3种色光称之为三原色光，分别简称为R&#x2F;G&#x2F;B。</p><p><img src="https://pic2.zhimg.com/v2-3de9a37e33e7c3c8d70f06baf1a9730f_1440w.jpg" alt="img"></p><p><img src="https://pica.zhimg.com/v2-95f35ddbea66d0cf5a2e36ed6c01f828_1440w.jpg" alt="img"></p><p><strong>色彩的范畴</strong></p><p>　　色彩分为无色彩与有色彩两大范畴。</p><p>　　无色彩指无单色光，即：黑、白、灰；</p><p>　　有色彩指有单色光，即：红、橙、黄、绿、蓝、紫；</p><p>自然界的色彩虽然各不相同</p><p>但任何色彩都具有<strong>色相、明度、饱和度</strong>这三个基本属性</p><p><img src="https://pic1.zhimg.com/v2-471ec29e760f7dcf149c6ea25c6d295a_1440w.jpg" alt="img"></p><p><strong>色相</strong></p><p>色相是指色彩的相貌，即各种颜色之间的区别，是色彩最显著的特征，它是不同波长的色光被感觉的结果，光谱中有红、橙、黄、绿、蓝、紫6种基本色光</p><p><strong>饱和度</strong></p><p>饱和度是指色彩的鲜艳程度，也称色彩的纯度，饱和度取决于该色中含色成分和消色成分的比例，含色成分越大，饱和度越高，消色成分越大，饱和度越低。</p><p><strong>明度</strong></p><p>明度是指色彩的深浅，明暗，它取决于反射光的强度，在无色彩中，明度最高的色为白色，明度最低的色为黑色，中间存在一个从亮到暗的灰色系列。在在彩色中，任何一种纯度都有着自己的明度物特征。例如：黄色为明度最高的色，紫色为明度最低的色。</p><hr><p><strong>暖色调</strong></p><p>即红色、橙色、黄色、赭色等色彩的搭配。这种色调的运用，可使主页呈现温馨、和煦、热情的氛围。</p><p><img src="https://pica.zhimg.com/v2-443aa5901bb0157a8ca6245f3a2d5aa8_1440w.jpg" alt="img"></p><p>暖色调</p><p><strong>冷色调</strong></p><p>即青色、绿色、紫色等色彩的搭配。这种色调的运用，可使主页呈现宁静、清凉、高雅的氛围。</p><p><img src="https://pic3.zhimg.com/v2-1ee58abc43589cc3f0e0d4a10f5e7692_1440w.jpg" alt="img"></p><p>冷色调</p><p><strong>对比色调</strong></p><p>即把色性完全相反的色彩搭配在同一个空间里。例如：红与绿、黄与紫、橙与蓝等。这种色彩的搭配，可以产生强烈的视觉效果，给人亮丽、鲜艳、喜庆的感觉。当然，对比色调如果用得不好，会适得其反，产生俗气、刺眼的不良效果。这就要把握“大调和，小对比”这一个重要原则，即总体的色调应该是统一和谐的，局部的地方可以有一些小的强烈对比。</p><p><img src="https://pica.zhimg.com/v2-b0082b901a33d90bffc5cfbb0042c650_1440w.jpg" alt="img"></p><p>对比色调</p><p>色彩的<strong>心理感觉</strong></p><p>不同的颜色会给浏览者不同的心理感受。</p><p><strong>红色</strong>—是一种激奋的色彩。刺激效果，能使人产生冲动，愤怒，热情，活力的感觉。</p><p><strong>绿色</strong>—介于冷暖两中色彩的中间，显得和睦，宁静，健康，安全的感觉。 它和金黄，淡白搭配，可以产生优雅，舒适的气氛。</p><p><strong>橙色</strong>—也是一种激奋的色彩，具有轻快，欢欣，热烈，温馨，时尚的效果。</p><p><strong>黄色</strong>—具有快乐，希望，智慧和轻快的个性，它的明度最高。</p><p><strong>蓝色</strong>—是最具凉爽，清新，专业的色彩。它和白色混合，能体现柔顺，淡雅，浪漫的气氛(象天空的色彩:)</p><p><strong>白色</strong>—具有洁白，明快，纯真，清洁的感受。</p><p><strong>黑色</strong>—具有深沉，神秘，寂静，悲哀，压抑的感受。</p><p><strong>灰色</strong>—具有中庸，平凡，温和，谦让，中立和高雅的感觉。</p><p>每种色彩在饱和度，透明度上略微变化就会产生不同的感觉。以绿色为例，黄绿色有青春，旺盛的视觉意境，而蓝绿色则显得幽宁，阴深。</p><h2 id="认识光线"><a href="#认识光线" class="headerlink" title="认识光线"></a>认识光线</h2><p><strong>光的特性</strong></p><p>无论是自然光或人工室内光,都有其特征：</p><p><strong>1.明暗度</strong>：明暗度表示光的强弱.它随光源能量和距离的变化而变化。</p><p><strong>2.方向</strong>：只有一个光源,方向很容易确定.而有多个光源诸如多云天气的漫射光,方向就难以确定,甚至完全迷失。</p><p><strong>3.色彩</strong>：光随不同的光的本源,并随它穿越的物质的不同而变化出多种色彩.自然光的色彩与白炽灯光或电子闪光灯作用下的色彩不同,而且阳光本身的色彩,也随大气条件和一天时辰的变化而变化。</p><p><strong>光的基本方向</strong></p><p>光线的方向是以光线的来源，被摄体及相机三者的相对位置来看。可分为顺光、逆光、侧光、侧顺光、侧逆光、顶光、底光。</p><p><img src="https://pic4.zhimg.com/v2-b6b0fcb89100ed11839e40c75b748555_1440w.jpg" alt="img"></p><p>光的基本方向</p><p><strong>1.顺光</strong></p><p>顺光时，被摄体受到均匀照明，景物的阴影被景物自身遮挡住，影调比较柔和。能拍出被摄体表面的质地和带来较好的色彩还原。表现空间立体感的效果也较差.</p><p><strong>优点</strong>：成像清晰，色彩、线条、形态、气氛都能得到真实的还原。</p><p><strong>缺点</strong>：呆板，立体感弱，缺少纵深。</p><p><strong>拍摄要点：</strong>要注意画面层次感和立体感的营造。可考虑通过色彩差异拉大主体与背景的分离度，提高画面立体感.</p><p><strong>2.逆光</strong></p><p>光线的照射方向与照相机的拍摄方向是相反的。主体人物的边缘有明显的光线轮廓，画面有明显的明暗反差。逆光又被称为“轮廓照明”， 是人像摄影中最讲究的一种用光方式，画面效果十分生动，且富有造型特点。</p><p><strong>优点</strong>：逆光具有很强的塑形感，有利于勾勒轮郭，表现空间层次和营造气氛。</p><p><strong>缺点</strong>：因照度极其不均，所以在曝光上很难把握。</p><p><strong>拍摄要点</strong>：</p><p>1.逆光拍摄时，为了防止镜头进光（特殊效果除外），尽量使用镜头遮光罩或是遮光板。</p><p>2.为防止画面明暗反差过大，可以使用反光板或闪光灯等补光工具控制亮度平衡。</p><p><strong>3.侧光</strong></p><p>光线的照射方向与照相机的拍摄方向成90度的夹角关系。主体人物有明显的受光面和背光面之分，光线的方向和明暗关系十分明确。侧光使被摄人物有鲜明的层次感和立体感，被称为“质感照明”。</p><p><strong>优点</strong>：被摄主体一侧受光便会产生强烈的明暗对比，使形态、线条、质感得以突出。</p><p><strong>缺点</strong>：侧光运用在人像摄影中，容易暴露皮肤的瑕疵，形成明暗过渡不均的“阴阳脸”。</p><p><strong>拍摄要点</strong>：1.运用侧光拍摄，适合表现个性鲜明、强硬的人物形象，不太适合一般强调浪漫的婚纱照。2.可以使用反光板或闪光灯对暗部进行补光，以减小光比，以适合婚纱柔和的画面效果。</p><p><strong>4.侧顺光</strong></p><p>光线的照射方向与照相机的拍摄方向成锐角夹角关系。侧顺光兼具顺光与侧光两种光线的特征，它既保证了被摄主体的亮度，又可以使其明暗对比得当，有很好的塑形效果。侧顺光是最常见的外景婚纱用光，也是单光源补光较理想的光线。</p><p><strong>优点</strong>：侧顺光拍摄出的画面中有丰富的影调和层次，不仅有利于表现人物的造型，还可以突出立体感。</p><p><strong>缺点</strong>：亮部和阴影部分的光比以及面积比例掌控很关键。</p><p><strong>拍摄要点</strong>：侧顺光下，人脸大面积处于受光面，所以应按亮部进行测光、曝光，如光比过大，暗部层次缺失严重，则需要利用补光工具给暗部补光，或降低亮部光强。</p><p><strong>5.侧逆光</strong></p><p>光线的照射方向与照相机的拍摄方向成钝角夹角关系。侧逆光兼具逆光与侧光两种光线的特征，采用侧逆光照明，被摄者面部和身体的受光面只占小部分，阴影面占大部分，人物的一侧有明显的轮廓光，能很好地表现被摄对象的立体感，层次丰富。侧逆光拍摄出的画面易产生很好的光影效果。</p><p><strong>优点</strong>：侧逆光具有很强空间感，画面层次丰富且生动活泼。</p><p><strong>缺点</strong>：容易因测光不准确而使画面曝光过度或不足。</p><p><strong>拍摄要点</strong>：</p><p>1.在外景婚纱摄影中，常常需要反光板、闪光灯等辅助照明设备适当提高阴影面的亮度，修饰阴影面的立体层次，改善阴影部分的立体感。</p><p>2.在拍摄人物中近景和特写时，有时作为主光用，有时作修饰光用。3.要根据侧逆光的用途确定光比，避免人物脸部大面积过暗，只有一亮线。</p><p><strong>6.顶光 底光</strong></p><p><strong>顶光</strong>顾名思义就是从头顶上照射下来的光线，又叫骷髅光。最具代表性的顶光就是正午的阳光，这种光线使凸出来的部分更明亮、凹进去的部分更阴暗，它会使人物的眼睛、鼻子下方出现难看的阴影。在外景婚纱拍摄中，应尽量避免使用顶光，如无法避免，则可以将反光板放置在人脸下放，消除阴影。</p><p><strong>底光</strong>是从人的脚下垂直照上来的光线，它往往会使被摄主体显得残暴，纯粹的底光容易形成阴险、恐怖、刻板的效果。底光更多出现在舞台戏剧照明中，而在外景婚纱拍摄中较少用到，但低角度的反光板、广场的地灯、桥下水流的反光等也带有底光的性质。</p><p><strong>自然光</strong></p><p><strong>明暗度</strong> 明暗度表示光的强弱。它随光源能量和距离的变化而变化。</p><p><strong>方向</strong> 如果只有一个光源，方向很容易确定。而有多个光源诸如多云天气的漫射光，方向就难以确定，甚至完全迷失。</p><p><strong>色彩</strong> 光随不同的光源，并随它穿越的物质的不同而变化出多种色彩。自然光的色彩与白炽灯光或电子闪光灯下的色彩不同，而且阳光本身的色彩，也随大气条件和一天时间的变化而变化。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <category domain="http://example.com/tags/%E6%91%84%E5%BD%B1/">摄影</category>
      
      
      <comments>http://example.com/2025/she-ying/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>可乐鸡翅</title>
      <link>http://example.com/2023/ke-le-ji-chi/</link>
      <guid>http://example.com/2023/ke-le-ji-chi/</guid>
      <pubDate>Sat, 20 May 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;材料：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;鸡翅10只&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可乐330毫升（一罐）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生姜3片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大葱1根&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>材料：</strong></p><ol><li><p>鸡翅10只</p></li><li><p>可乐330毫升（一罐）</p></li><li><p>生姜3片</p></li><li><p>大葱1根</p><span id="more"></span></li><li><p>生抽、老抽各适量</p></li><li><p>白糖两勺</p></li><li><p>料酒适量</p></li><li><p>食盐适量</p></li></ol><p><strong>步骤：</strong></p><ol><li><p>首先，清洗鸡翅并用刀在表面划几刀，以便入味。</p></li><li><p>生姜切片，大葱切段备用。</p></li><li><p>在锅中加入适量的油，热锅冷油可以防止鸡翅皮粘锅。(ps记得把鸡翅水吸干），加入生姜片炒香。</p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%8501.jpg" style="zoom:50%;" /></li><li><p>接着，把鸡翅放入锅中两面煎炒（ps把生姜片夹出），煎至两面微黄色。</p></li><li><p>加入两勺糖继续炒，炒至糖溶化并裹在鸡翅上，鸡翅色泽变深。</p></li><li><p>倒入适量的料酒，用中小火慢慢翻煎，让鸡翅充分吸收料酒的香味。</p></li><li><p>加入适量的生抽和老抽翻煎均匀，使鸡翅充分上色。</p></li><li><p>倒入一罐可乐（大约330ml），加入葱段，用中小火烧煮15-20分钟。</p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%8502.jpg"></p></li><li><p>最后，撇去浮沫，调入适量的盐炖煮至汤汁变粘稠即可。</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8E%A8%E6%88%BF/">厨房</category>
      
      
      <category domain="http://example.com/tags/%E4%B8%8B%E5%8E%A8%E6%88%BF/">下厨房</category>
      
      
      <comments>http://example.com/2023/ke-le-ji-chi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>selenium4.0更新</title>
      <link>http://example.com/2023/selenium/</link>
      <guid>http://example.com/2023/selenium/</guid>
      <pubDate>Wed, 22 Mar 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;selenium4-0&quot;&gt;&lt;a href=&quot;#selenium4-0&quot; class=&quot;headerlink&quot; title=&quot;selenium4.0&quot;&gt;&lt;/a&gt;selenium4.0&lt;/h1&gt;&lt;p&gt;Selenium 4 已经到来，将至少需要 &lt;strong&gt;Python 3.7 或更高版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面介绍一下基础的语法格式&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="selenium4-0"><a href="#selenium4-0" class="headerlink" title="selenium4.0"></a>selenium4.0</h1><p>Selenium 4 已经到来，将至少需要 <strong>Python 3.7 或更高版本。</strong></p><p>下面介绍一下基础的语法格式</p><span id="more"></span><h2 id="1、初始化浏览器、刷新、最大化、后退、前进、截图"><a href="#1、初始化浏览器、刷新、最大化、后退、前进、截图" class="headerlink" title="1、初始化浏览器、刷新、最大化、后退、前进、截图"></a>1、初始化浏览器、刷新、最大化、后退、前进、截图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化浏览器为谷歌浏览器</span></span><br><span class="line"><span class="built_in">chr</span>=webdriver.Chrome()</span><br><span class="line"><span class="comment"># 无界面的浏览器</span></span><br><span class="line"><span class="comment"># option = webdriver.ChromeOptions()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># option.add_argument(&quot;headless&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># chr = webdriver.Chrome(options=option)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浏览器最大化</span></span><br><span class="line"><span class="built_in">chr</span>.maximize_window()</span><br><span class="line"></span><br><span class="line"><span class="built_in">chr</span>.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chr.get(&quot;https://www.jd.com/&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后退</span></span><br><span class="line"><span class="built_in">chr</span>.back()</span><br><span class="line"><span class="comment">#暂停2s</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#前进</span></span><br><span class="line"><span class="built_in">chr</span>.forward()</span><br><span class="line"><span class="comment">#刷新</span></span><br><span class="line"><span class="built_in">chr</span>.refresh()</span><br><span class="line"><span class="comment">#截图</span></span><br><span class="line"><span class="built_in">chr</span>.get_screenshot_as_file(<span class="string">&#x27;截图.png&#x27;</span>)</span><br><span class="line"><span class="comment">#点击</span></span><br><span class="line"><span class="built_in">chr</span>.find_element(By.ID,<span class="string">&#x27;kw&#x27;</span>).click()</span><br><span class="line"><span class="comment">#输入</span></span><br><span class="line"><span class="built_in">chr</span>.find_element(By.ID,<span class="string">&#x27;kw&#x27;</span>).send_keys(<span class="string">&quot;saa&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#清除输入框内容</span></span><br><span class="line"><span class="built_in">chr</span>.find_element(By.ID,<span class="string">&#x27;kw&#x27;</span>).clear()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#关闭浏览器</span></span><br><span class="line"><span class="built_in">chr</span>.close()</span><br></pre></td></tr></table></figure><h2 id="2、单个元素定位的方法"><a href="#2、单个元素定位的方法" class="headerlink" title="2、单个元素定位的方法"></a>2、单个元素定位的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">selenium4使用的时候需要导入模块    <span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">find_element(By.XPATH, <span class="string">&quot;//*[@id=&#x27;search&#x27;]&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.CLASS_NAME, <span class="string">&quot;element_class_name&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.ID,<span class="string">&quot;element_id&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.NAME, <span class="string">&quot;element_name&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.LINK_TEXT,<span class="string">&quot;element_link_text&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.CSS_SELECTOR, <span class="string">&quot;element_css_selector&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.TAG_NAME, <span class="string">&quot;element_tag_name&quot;</span>)</span><br><span class="line"></span><br><span class="line">find_element(By.PARTIAL_LINK_TEXT, <span class="string">&quot;element_partial_link_text&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="3、多个元素定位的方法"><a href="#3、多个元素定位的方法" class="headerlink" title="3、多个元素定位的方法"></a>3、多个元素定位的方法</h2><p>与单个元素的定位方式类似，把find_element改成find_elements即可</p><h2 id="4、定位select类型的下拉框"><a href="#4、定位select类型的下拉框" class="headerlink" title="4、定位select类型的下拉框"></a>4、定位select类型的下拉框</h2><p>4、定位select类型的下拉框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select_by_index()           <span class="comment"># 通过索引定位；注意：&gt;index索引是从“0”开始。</span></span><br><span class="line">select_by_value()           <span class="comment"># 通过value值定位，va&gt;lue标签的属性值。</span></span><br><span class="line">select_by_visible_text()    <span class="comment"># 通过文本值定位，即显&gt;示在下拉框的值。</span></span><br><span class="line">Select(<span class="built_in">chr</span>.find_element_by_name(<span class="string">&quot;姓名&quot;</span>)).select_by_index(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>或者分开写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">chr</span>.find_element_by_name(<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line"></span><br><span class="line">Select(a).select_by_index(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="5、多窗口切换"><a href="#5、多窗口切换" class="headerlink" title="5、多窗口切换"></a>5、多窗口切换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">current_window_handle：获取当前窗口的句柄</span><br><span class="line"></span><br><span class="line">window_handles：返回当前浏览器的所有窗口的句柄</span><br><span class="line"></span><br><span class="line">switch_to_window()：用于切换到对应的窗口</span><br><span class="line"></span><br><span class="line"><span class="built_in">chr</span>.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">a=<span class="built_in">chr</span>.current_window_handle</span><br><span class="line"><span class="built_in">chr</span>.execute_script(<span class="string">&#x27;window.open()&#x27;</span>)</span><br><span class="line"><span class="built_in">chr</span>.switch_to.window(<span class="built_in">chr</span>.window_handles[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">chr</span>.get(<span class="string">&quot;https://www.jd.com/&quot;</span>)</span><br><span class="line"><span class="comment"># chr.switch_to.window(chr.window_handles[0])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chr</span>.switch_to.window(a)</span><br></pre></td></tr></table></figure><h2 id="6、iframe切换"><a href="#6、iframe切换" class="headerlink" title="6、iframe切换"></a>6、iframe切换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.frame(driver.find_element_by_xpath(<span class="string">&quot;//iframe[contains(@src,&#x27;myframe&#x27;)]&quot;</span>))</span><br></pre></td></tr></table></figure><p>#回到默认的iframe</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.default_content()</span><br></pre></td></tr></table></figure><h2 id="7、键盘操作"><a href="#7、键盘操作" class="headerlink" title="7、键盘操作"></a>7、键盘操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">send_keys(Keys.BACK_SPACE)：删除键(BackSpace)</span><br><span class="line"></span><br><span class="line">send_keys(Keys.SPACE)：空格键(Space)</span><br><span class="line"></span><br><span class="line">send_keys(Keys.TAB)：制表键(TAB)</span><br><span class="line"></span><br><span class="line">send_keys(Keys.ESCAPE)：回退键(ESCAPE)</span><br><span class="line"></span><br><span class="line">send_keys(Keys.ENTER)：回车键(ENTER)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%B5%8B%E8%AF%95/">测试</category>
      
      
      <category domain="http://example.com/tags/%E6%B5%8B%E8%AF%95/">测试</category>
      
      <category domain="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</category>
      
      
      <comments>http://example.com/2023/selenium/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>美团笔试3.18后端</title>
      <link>http://example.com/2023/mei-tuan-bi-shi/</link>
      <guid>http://example.com/2023/mei-tuan-bi-shi/</guid>
      <pubDate>Wed, 22 Mar 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;1-捕获敌人&quot;&gt;&lt;a href=&quot;#1-捕获敌人&quot; class=&quot;headerlink&quot; title=&quot;1. 捕获敌人&quot;&gt;&lt;/a&gt;1. 捕获敌人&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小美在玩一项游戏。该游戏的目标是尽可能抓获敌人。&lt;/p&gt;
&lt;p&gt;敌人的位置将被一个二维坐标(&lt;em&gt;x&lt;/em&gt;,&lt;em&gt;y&lt;/em&gt;) 所描述。&lt;/p&gt;
&lt;p&gt;小美有一个全屏技能，该技能能一次性将若干敌人一次性捕获。捕获的敌人之间的横坐标的最大差值不能大于 &lt;em&gt;A&lt;/em&gt;，纵坐标的最大差值不能大于 &lt;em&gt;B&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;现在给出所有敌人的坐标，你的任务是计算小美一次性最多能使用技能捕获多少敌人。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-捕获敌人"><a href="#1-捕获敌人" class="headerlink" title="1. 捕获敌人"></a>1. 捕获敌人</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小美在玩一项游戏。该游戏的目标是尽可能抓获敌人。</p><p>敌人的位置将被一个二维坐标(<em>x</em>,<em>y</em>) 所描述。</p><p>小美有一个全屏技能，该技能能一次性将若干敌人一次性捕获。捕获的敌人之间的横坐标的最大差值不能大于 <em>A</em>，纵坐标的最大差值不能大于 <em>B</em> 。</p><p>现在给出所有敌人的坐标，你的任务是计算小美一次性最多能使用技能捕获多少敌人。</p><span id="more"></span><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行三个整数 N*,<em>A</em>,<em>B</em>，表示共有 N* 个敌人，小美的全屏技能的参数 <em>A</em> 和参数 <em>B</em>。</p><p>接下来 <em>N</em> 行，每行两个数字 <em>x</em>,<em>y</em>，描述一个敌人所在的坐标。</p><p>1⩽N⩽500,1⩽A,B⩽1000,1⩽x,y⩽1000</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>一行，一个整数表示小美使用技能单次所可以捕获的最多数量。</p><h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 1 1</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：最多可以同时捕获两名敌人，可以是 (1,1)(1,1) 和 (1,2)(1,2) 处的敌人，也可以是 (1,2)(1,2) 和 (1,3)(1,3) 处的敌人，但不可以同时捕获三名敌人，因为三名敌人时，纵坐标的最大差值是 22，超过了参数 B* 的值 11。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>二维前缀和：就是在一个大矩形中有若干个点，给我们一个小矩阵，看它最多能框住多少个点。</p><p>所以我们先读入敌人坐标，将有敌人的坐标初始化为 1。</p><p>然后用二维前缀和预处理，再枚举每一个范围内 (<em>A</em>,<em>B</em>) 的子矩阵，取一个 <strong>max</strong>即可。</p><p>时间复杂度 <em>O</em>(<em>N</em>2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">10</span>][N + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(), a = sc.nextInt(), b = sc.nextInt();</span><br><span class="line">        a++; b++; <span class="comment">// 最大间隔++，前缀和下标从1开始处理，防止边界问题</span></span><br><span class="line">        <span class="comment">// 与N取min</span></span><br><span class="line">        a = Math.min(a, N);</span><br><span class="line">        b = Math.min(b, N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt(), y = sc.nextInt();</span><br><span class="line">            g[x][y]++; <span class="comment">// 读入敌人坐标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                g[i][j] += g[i - <span class="number">1</span>][j] + g[i][j - <span class="number">1</span>] - g[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 二维前缀和预处理 公式一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举一下所有长宽是ab的矩形，(i,j)为右下角，取max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b; j &lt;= N; j++) &#123;</span><br><span class="line">                res = Math.max(res, g[i][j] - g[i - a][j] - g[i][j - b] + g[i - a][j - b]); <span class="comment">// 求某一个子矩阵的值 公式二</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-截彩带"><a href="#2-截彩带" class="headerlink" title="2. 截彩带"></a>2. 截彩带</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>小美现在有一串彩带，假定每一厘米的彩带上都是一种色彩。</p><p>因为任务的需要，小美希望从彩带上截取一段，使得彩带中的颜色数量不超过 <em>K</em> 种。</p><p>显然，这样的截取方法可能非常多。于是小美决定尽量长地截取一段。你的任务是帮助小美截取尽量长的一段，使得这段彩带上不同的色彩数量不超过 <em>K</em> 种。</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行两个整数 N*,<em>K</em>，以空格分开，分别表示彩带有 N* 厘米长，你截取的一段连续的彩带不能超过 K* 种颜色。接下来一行 N* 个整数，每个整数表示一种色彩，相同的整数表示相同的色彩。</p><p>1≤<em>N</em>,<em>K</em>≤5000，彩带上的颜色数字介于 [1,2000][1,2000] 之间。</p><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h3><p>一行，一个整数，表示选取的彩带的最大长度。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 2 3 2 1 4 5 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>说明：最长的一段彩带是 [1,2,3,2,1][1,2,3,2,1] 共 55 厘米。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>求连续子数组最大和，但此题还要求区间的种类数不能超过 K* 种，所以在<code>双指针</code>的基础上我们还需要用 <strong><code>哈希</code></strong> 来维护区间的种类数。</p><p><strong>暴力解法</strong></p><p>直接两重循环，用 <code>set</code> 维护区间种类数。</p><p>时间复杂度 O*(<em>N</em>2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(), k = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) a[i] = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                set.add(a[j]);</span><br><span class="line">                <span class="keyword">if</span> (set.size() &gt; k) <span class="keyword">break</span>;</span><br><span class="line">                res = Math.max(res, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双指针 + map</strong></p><p>时间复杂度 O*(<em>N</em>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(), k = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i] = sc.nextInt();</span><br><span class="line">            add(a[i]);</span><br><span class="line">            <span class="keyword">while</span> (num &gt; k) &#123;</span><br><span class="line">                sub(a[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (++cnt[x] == <span class="number">1</span>) num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[x] == <span class="number">0</span>) num--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/">笔试记录</category>
      
      
      <category domain="http://example.com/tags/%E7%AC%94%E8%AF%95/">笔试</category>
      
      
      <comments>http://example.com/2023/mei-tuan-bi-shi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线程池篇</title>
      <link>http://example.com/2023/java-ba-gu-xian-cheng-chi/</link>
      <guid>http://example.com/2023/java-ba-gu-xian-cheng-chi/</guid>
      <pubDate>Mon, 20 Mar 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;为什么要使用线程池？直接new个线程不是很舒服？&quot;&gt;&lt;a href=&quot;#为什么要使用线程池？直接new个线程不是很舒服？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池？直接new个线程不是很舒服？&quot;&gt;&lt;/a&gt;为什么要使用线程池？直接new个线程不是很舒服？&lt;/h1&gt;&lt;p&gt;使用线程池可以带来以下几个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="为什么要使用线程池？直接new个线程不是很舒服？"><a href="#为什么要使用线程池？直接new个线程不是很舒服？" class="headerlink" title="为什么要使用线程池？直接new个线程不是很舒服？"></a>为什么要使用线程池？直接new个线程不是很舒服？</h1><p>使用线程池可以带来以下几个好处：</p><ol><li><p>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。</p><span id="more"></span></li></ol><h1 id="线程池的核心属性有哪些？"><a href="#线程池的核心属性有哪些？" class="headerlink" title="线程池的核心属性有哪些？"></a>线程池的核心属性有哪些？</h1><p>threadFactory（线程工厂）：用于创建工作线程的工厂。</p><p>corePoolSize（核心线程数）：当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其他工作线程处于空闲状态。</p><p>workQueue（队列）：用于保留任务并移交给工作线程的阻塞队列。</p><p>maximumPoolSize（最大线程数）：线程池允许开启的最大线程数。</p><p>handler（拒绝策略）：往线程池添加任务时，将在下面两种情况触发拒绝策略：1）线程池运行状态不是 RUNNING；2）线程池已经达到最大线程数，并且阻塞队列已满时。</p><p>keepAliveTime（保持存活时间）：如果线程池当前线程数超过 corePoolSize，则多余的线程空闲时间超过 keepAliveTime 时会被终止。</p><h1 id="线程池中的各个状态分别代表什么含义？"><a href="#线程池中的各个状态分别代表什么含义？" class="headerlink" title="线程池中的各个状态分别代表什么含义？"></a>线程池中的各个状态分别代表什么含义？</h1><p>线程池目前有5个状态：</p><p>RUNNING：接受新任务并处理排队的任务。</p><p>SHUTDOWN：不接受新任务，但处理排队的任务。</p><p>STOP：不接受新任务，不处理排队的任务，并中断正在进行的任务。</p><p>TIDYING：所有任务都已终止，workerCount 为零，线程转换到 TIDYING 状态将运行 terminated() 钩子方法。</p><p>TERMINATED：terminated() 已完成。</p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkh6RlM2UE9nNlRnaWNpY3Y1SU10TGliV2pHODFzOHF1TFByWWw.png"></p><h1 id="使用队列有什么需要注意的吗？"><a href="#使用队列有什么需要注意的吗？" class="headerlink" title="使用队列有什么需要注意的吗？"></a>使用队列有什么需要注意的吗？</h1><p>使用有界队列时，需要注意线程池满了后，被拒绝的任务如何处理。</p><p>使用无界队列时，需要注意如果任务的提交速度大于线程池的处理速度，可能会导致内存溢出。</p><h1 id="线程池有哪些拒绝策略？"><a href="#线程池有哪些拒绝策略？" class="headerlink" title="线程池有哪些拒绝策略？"></a>线程池有哪些拒绝策略？</h1><p>常见的有以下几种：</p><p>AbortPolicy：中止策略。默认的拒绝策略，直接抛出 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p><p>DiscardPolicy：抛弃策略。什么都不做，直接抛弃被拒绝的任务。</p><p>DiscardOldestPolicy：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和优先级队列放在一起使用。</p><p>CallerRunsPolicy：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。</p><h1 id="如何终止线程池？"><a href="#如何终止线程池？" class="headerlink" title="如何终止线程池？"></a>如何终止线程池？</h1><p>终止线程池主要有两种方式：</p><p>shutdown：“温柔”的关闭线程池。不接受新任务，但是在关闭前会将之前提交的任务处理完毕。</p><p>shutdownNow：“粗暴”的关闭线程池，也就是直接关闭线程池，通过 Thread#interrupt() 方法终止所有线程，不会等待之前提交的任务执行完毕。但是会返回队列中未处理的任务。</p><h1 id="Executors-提供了哪些创建线程池的方法？"><a href="#Executors-提供了哪些创建线程池的方法？" class="headerlink" title="Executors 提供了哪些创建线程池的方法？"></a>Executors 提供了哪些创建线程池的方法？</h1><p>newFixedThreadPool：固定线程数的线程池。corePoolSize &#x3D; maximumPoolSize，keepAliveTime为0，工作队列使用无界的LinkedBlockingQueue。适用于为了满足资源管理的需求，而需要限制当前线程数量的场景，适用于负载比较重的服务器。</p><p>newSingleThreadExecutor：只有一个线程的线程池。corePoolSize &#x3D; maximumPoolSize &#x3D; 1，keepAliveTime为0， 工作队列使用无界的LinkedBlockingQueue。适用于需要保证顺序的执行各个任务的场景。</p><p>newCachedThreadPool： 按需要创建新线程的线程池。核心线程数为0，最大线程数为 Integer.MAX_VALUE，keepAliveTime为60秒，工作队列使用同步移交 SynchronousQueue。该线程池可以无限扩展，当需求增加时，可以添加新的线程，而当需求降低时会自动回收空闲线程。适用于执行很多的短期异步任务，或者是负载较轻的服务器。</p><p>newScheduledThreadPool：创建一个以延迟或定时的方式来执行任务的线程池，工作队列为 DelayedWorkQueue。适用于需要多个后台线程执行周期任务。</p><p>newWorkStealingPool：JDK 1.8 新增，用于创建一个可以窃取的线程池，底层使用 ForkJoinPool 实现。</p><h1 id="在我们实际使用中，线程池的大小配置多少合适？"><a href="#在我们实际使用中，线程池的大小配置多少合适？" class="headerlink" title="在我们实际使用中，线程池的大小配置多少合适？"></a>在我们实际使用中，线程池的大小配置多少合适？</h1><p>要想合理的配置线程池大小，首先我们需要区分任务是计算密集型还是I&#x2F;O密集型。</p><p>对于计算密集型，设置 线程数 &#x3D; CPU数 + 1，通常能实现最优的利用率。</p><p>对于I&#x2F;O密集型，网上常见的说法是设置 线程数 &#x3D; CPU数 * 2 ，这个做法是可以的，但个人觉得不是最优的。</p><p>在我们日常的开发中，我们的任务几乎是离不开I&#x2F;O的，常见的网络I&#x2F;O（RPC调用）、磁盘I&#x2F;O（数据库操作），并且I&#x2F;O的等待时间通常会占整个任务处理时间的很大一部分，在这种情况下，开启更多的线程可以让 CPU 得到更充分的使用，一个较合理的计算公式如下：</p><p>线程数 &#x3D; CPU数 * CPU利用率 * (任务等待时间 &#x2F; 任务计算时间 + 1)</p><p>例如我们有个定时任务，部署在4核的服务器上，该任务有100ms在计算，900ms在I&#x2F;O等待，则线程数约为：4 * 1 * (1 + 900 &#x2F; 100) &#x3D; 40个。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">面试八股</category>
      
      
      <category domain="http://example.com/tags/Java/">Java</category>
      
      
      <comments>http://example.com/2023/java-ba-gu-xian-cheng-chi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MYSQL篇</title>
      <link>http://example.com/2023/java-ba-gu-mysql/</link>
      <guid>http://example.com/2023/java-ba-gu-mysql/</guid>
      <pubDate>Mon, 20 Mar 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;MySQL-的事务隔离级别有哪些？分别用于解决什么问题？&quot;&gt;&lt;a href=&quot;#MySQL-的事务隔离级别有哪些？分别用于解决什么问题？&quot; class=&quot;headerlink&quot; title=&quot;MySQL 的事务隔离级别有哪些？分别用于解决什么问题？&quot;&gt;&lt;/a&gt;MySQL 的事务隔离级别有哪些？分别用于解决什么问题？&lt;/h1&gt;&lt;p&gt;主要用于解决脏读、不可重复读、幻读。&lt;/p&gt;
&lt;p&gt;脏读：一个事务读取到另一个事务还未提交的数据。&lt;/p&gt;
&lt;p&gt;不可重复读：在一个事务中多次读取同一个数据时，结果出现不一致。&lt;/p&gt;
&lt;p&gt;幻读：在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行。&lt;/p&gt;
&lt;p&gt;不可重复读注重于数据的修改，而幻读注重于数据的插入。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="MySQL-的事务隔离级别有哪些？分别用于解决什么问题？"><a href="#MySQL-的事务隔离级别有哪些？分别用于解决什么问题？" class="headerlink" title="MySQL 的事务隔离级别有哪些？分别用于解决什么问题？"></a>MySQL 的事务隔离级别有哪些？分别用于解决什么问题？</h1><p>主要用于解决脏读、不可重复读、幻读。</p><p>脏读：一个事务读取到另一个事务还未提交的数据。</p><p>不可重复读：在一个事务中多次读取同一个数据时，结果出现不一致。</p><p>幻读：在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行。</p><p>不可重复读注重于数据的修改，而幻读注重于数据的插入。</p><span id="more"></span><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（Read Uncommitted）</td><td>有</td><td>有</td><td>有</td></tr><tr><td>读已提交（Read Committed）</td><td>无</td><td>有</td><td>有</td></tr><tr><td>可重复读（Repeatable Read）</td><td>无</td><td>无</td><td>有</td></tr><tr><td>串行化（Serializable）</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><h1 id="MySQL-的可重复读怎么实现的？"><a href="#MySQL-的可重复读怎么实现的？" class="headerlink" title="MySQL 的可重复读怎么实现的？"></a>MySQL 的可重复读怎么实现的？</h1><p>使用 MVCC 实现的，即 Mutil-Version Concurrency Control，多版本并发控制。关于 MVCC，比较常见的说法如下，包括《高性能 MySQL》也是这么介绍的。</p><p>InnoDB 在每行记录后面保存两个隐藏的列，分别保存了数据行的创建版本号和删除版本号。每开始一个新的事务，系统版本号都会递增。事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录的版本号对比。在可重复读级别下，MVCC是如何操作的：</p><p>SELECT：必须同时满足以下两个条件，才能查询到。1）只查版本号早于当前版本的数据行；2）行的删除版本要么未定义，要么大于当前事务版本号。</p><p>INSERT：为插入的每一行保存当前系统版本号作为创建版本号。</p><p>DELETE：为删除的每一行保存当前系统版本号作为删除版本号。</p><p>UPDATE：插入一条新数据，保存当前系统版本号作为创建版本号。同时保存当前系统版本号作为原来的数据行删除版本号。</p><p>MVCC 只作用于 RC（Read Committed）和 RR（Repeatable Read）级别，因为 RU（Read Uncommitted）总是读取最新的数据版本，而不是符合当前事务版本的数据行。而 Serializable 则会对所有读取的行都加锁。这两种级别都不需要 MVCC 的帮助。</p><h1 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h1><p>MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。简单的理解，索引类似于字典里面的目录。</p><p>常见的索引类型有：hash、b树、b+树。</p><p>hash：底层就是 hash 表。进行查找时，根据 key 调用hash 函数获得对应的 hashcode，根据 hashcode 找到对应的数据行地址，根据地址拿到对应的数据。</p><p>B树：B树是一种多路搜索树，n 路搜索树代表每个节点最多有 n 个子节点。每个节点存储 key + 指向下一层节点的指针+ 指向 key 数据记录的地址。查找时，从根结点向下进行查找，直到找到对应的key。</p><p>B+树：B+树是b树的变种，主要区别在于：B+树的非叶子节点只存储 key + 指向下一层节点的指针。另外，B+树的叶子节点之间通过指针来连接，构成一个有序链表，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。</p><h1 id="为什么MySQL数据库要用B-树存储索引？而不用红黑树、Hash、B树？"><a href="#为什么MySQL数据库要用B-树存储索引？而不用红黑树、Hash、B树？" class="headerlink" title="为什么MySQL数据库要用B+树存储索引？而不用红黑树、Hash、B树？"></a>为什么MySQL数据库要用B+树存储索引？而不用红黑树、Hash、B树？</h1><p>红黑树：如果在内存中，红黑树的查找效率比B树更高，但是涉及到磁盘操作，B树就更优了。因为红黑树是二叉树，数据量大时树的层数很高，从树的根结点向下寻找的过程，每读1个节点，都相当于一次IO操作，因此红黑树的I&#x2F;O操作会比B树多的多。</p><p>hash 索引：如果只查询单个值的话，hash 索引的效率非常高。但是 hash 索引有几个问题：</p><ol><li>不支持范围查询；</li><li>不支持索引值的排序操作；</li><li>不支持联合索引的最左匹配规则。</li></ol><p>B树索引：B树索相比于B+树，在进行范围查询时，需要做局部的中序遍历，可能要跨层访问，跨层访问代表着要进行额外的磁盘I&#x2F;O操作；另外，B树的非叶子节点存放了数据记录的地址，会导致存放的节点更少，树的层数变高。</p><h1 id="MySQL-中的索引叶子节点存放的是什么？"><a href="#MySQL-中的索引叶子节点存放的是什么？" class="headerlink" title="MySQL 中的索引叶子节点存放的是什么？"></a>MySQL 中的索引叶子节点存放的是什么？</h1><p>MyISAM和InnoDB都是采用的B+树作为索引结构，但是叶子节点的存储上有些不同。</p><p>MyISAM：主键索引和辅助索引（普通索引）的叶子节点都是存放 key 和 key 对应数据行的地址。在MyISAM 中，主键索引和辅助索引没有任何区别。</p><p>InnoDB：主键索引存放的是 key 和 key 对应的数据行。辅助索引存放的是 key 和 key 对应的主键值。因此在使用辅助索引时，通常需要检索两次索引，首先检索辅助索引获得主键值，然后用主键值到主键索引中检索获得记录。</p><h1 id="什么是聚簇索引（聚集索引）？"><a href="#什么是聚簇索引（聚集索引）？" class="headerlink" title="什么是聚簇索引（聚集索引）？"></a>什么是聚簇索引（聚集索引）？</h1><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引将索引和数据行放到了一块，找到索引也就找到了数据。因为无需进行回表操作，所以效率很高。</p><p>InnoDB 中必然会有，且只会有一个聚簇索引。通常是主键，如果没有主键，则优先选择非空的唯一索引，如果唯一索引也没有，则会创建一个隐藏的row_id 作为聚簇索引。至于为啥会只有一个聚簇索引，其实很简单，因为我们的数据只会存储一份。</p><p>而非聚簇索引则将数据存储和索引分开，找到索引后，需要通过对应的地址找到对应的数据行。MyISAM 的索引方式就是非聚簇索引。</p><h1 id="什么是回表查询？"><a href="#什么是回表查询？" class="headerlink" title="什么是回表查询？"></a>什么是回表查询？</h1><p>InnoDB 中，对于主键索引，只需要走一遍主键索引的查询就能在叶子节点拿到数据。</p><p>而对于普通索引，叶子节点存储的是 key + 主键值，因此需要再走一次主键索引，通过主键索引找到行记录，这就是所谓的回表查询，先定位主键值，再定位行记录。</p><h1 id="走普通索引，一定会出现回表查询吗？"><a href="#走普通索引，一定会出现回表查询吗？" class="headerlink" title="走普通索引，一定会出现回表查询吗？"></a>走普通索引，一定会出现回表查询吗？</h1><p>不一定，如果查询语句所要求的字段全部命中了索引，那么就不必再进行回表查询。</p><p>很容易理解，有一个 user 表，主键为 id，name 为普通索引，则再执行：select id, name from user where name &#x3D; ‘joonwhee’ 时，通过name 的索引就能拿到 id 和 name了，因此无需再回表去查数据行了。</p><h1 id="什么是覆盖索引（索引覆盖）吗？"><a href="#什么是覆盖索引（索引覆盖）吗？" class="headerlink" title="什么是覆盖索引（索引覆盖）吗？"></a>什么是覆盖索引（索引覆盖）吗？</h1><p>覆盖索引是 SQL-Server 中的一种说法，上面讲的例子其实就实现了覆盖索引。具体的：当索引上包含了查询语句中的所有列时，我们无需进行回表查询就能拿到所有的请求数据，因此速度会很快。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">面试八股</category>
      
      
      <category domain="http://example.com/tags/Java/">Java</category>
      
      
      <comments>http://example.com/2023/java-ba-gu-mysql/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>刷题日志</title>
      <link>http://example.com/2023/leetcode/</link>
      <guid>http://example.com/2023/leetcode/</guid>
      <pubDate>Tue, 28 Feb 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;种一棵树最好的时间是十年前，或者现在&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>种一棵树最好的时间是十年前，或者现在</p><span id="more"></span><p><strong>2023.3.14</strong></p><p>1.两数之和</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><details>   <summary>思路1:通过双循环暴力计算两个数的和；</summary>   <pre><code> class Solution &#123;        public int[] twoSum(int[] nums, int target) &#123;        int n = nums.length;        for (int i = 0; i < n; ++i) &#123;            for (int j = i + 1; j < n; ++j) &#123;                if (nums[i] + nums[j] == target) &#123;                    return new int[]&#123;i, j&#125;;                &#125;            &#125;        &#125;        return new int[0];    &#125;&#125; </code></pre> </details><p>思路二：使用哈希表建立索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">          Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              map(数组值，脚标);</span><br><span class="line">              <span class="comment">//循环比较如果 num[i] + map.get(数组值)（存在时）退出循环</span></span><br><span class="line">              <span class="keyword">if</span>(map.get(target - nums[i]) != <span class="literal">null</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//不存在则保存该值</span></span><br><span class="line">              map.put(nums[i],i);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//结束循环，不存在</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="1624"><li>两个相同字符之间的最长子字符串</li></ol><p>给你一个字符串 <code>s</code>，请你返回 <strong>两个相同字符之间的最长子字符串的长度</strong> <em>，</em>计算长度时不含这两个字符。如果不存在这样的子字符串，返回 <code>-1</code> 。</p><p><strong>子字符串</strong> 是字符串中的一个连续字符序列。 </p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：最优的子字符串是两个 &#x27;a&#x27; 之间的空子字符串。</span><br></pre></td></tr></table></figure><p>思路：通过哈希表记录最开始出现的位置，然后比较后面的出现时距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLengthBetweenEqualCharacters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(s.length() &gt;&gt; <span class="number">1</span>);<span class="comment">//map&lt;字母，第一次位置&gt;</span></span><br><span class="line">        <span class="type">int</span> max=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">//获取当前字母，如果表内不存在则记录位置</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(c)==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map.put(c,i);</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        max = Math.max(max,i-map.get(c)-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2023.3.20</strong></p><p>合并两个有序链表:</p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(l1==<span class="literal">null</span>)</span><br><span class="line">     <span class="keyword">return</span> l2;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="literal">null</span>)</span><br><span class="line">     <span class="keyword">return</span> l1;</span><br><span class="line">     <span class="keyword">if</span>(l1.val&lt;l2.val)</span><br><span class="line">     &#123;</span><br><span class="line">         l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">         <span class="keyword">return</span> l1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;  </span><br><span class="line">         l2.next = mergeTwoLists(l2.next,l1);</span><br><span class="line">         <span class="keyword">return</span> l2;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除排序链表中的重复元素</strong></p><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>环形链表</strong></p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="literal">null</span> ||head.next == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span>head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">null</span> || fast.next==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只出现一次的数字</strong></p><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; Net = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">            &#123;<span class="comment">//当他无法被加入时删除他</span></span><br><span class="line">                <span class="keyword">if</span>(!Net.add(num))</span><br><span class="line">                Net.remove(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Net.isEmpty()?-<span class="number">1</span>:Net.iterator().next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">reduce</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用异或，将相同的两个数字抵消</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            reduce =  reduce ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reduce;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2023.3.25</strong></p><p><strong>无重复字符的最长子串</strong></p><p>定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>, start = <span class="number">0</span>; end &lt; n; end++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">alpha</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">            <span class="comment">//如果已经出现过，则更新左下标</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(alpha)) &#123;</span><br><span class="line">                <span class="comment">//抛弃上一次的重复字符</span></span><br><span class="line">                start = Math.max(map.get(alpha), start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算无重复字串长度，取最大</span></span><br><span class="line">            ans = Math.max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//记录字符最新位置</span></span><br><span class="line">            map.put(alpha, end + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8A%9B%E6%89%A3%E8%AE%B0%E5%BD%95/">力扣记录</category>
      
      
      <category domain="http://example.com/tags/%E5%88%B7%E9%A2%98/">刷题</category>
      
      
      <comments>http://example.com/2023/leetcode/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis基础</title>
      <link>http://example.com/2023/redis-ji-chu-pian/</link>
      <guid>http://example.com/2023/redis-ji-chu-pian/</guid>
      <pubDate>Thu, 05 Jan 2023 16:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;一、Redis入门&quot;&gt;&lt;a href=&quot;#一、Redis入门&quot; class=&quot;headerlink&quot; title=&quot;一、Redis入门&quot;&gt;&lt;/a&gt;一、Redis入门&lt;/h1&gt;&lt;h2 id=&quot;1-认识NoSQL&quot;&gt;&lt;a href=&quot;#1-认识NoSQL&quot; class=&quot;headerlink&quot; title=&quot;1.认识NoSQL&quot;&gt;&lt;/a&gt;1.认识NoSQL&lt;/h2&gt;&lt;h3 id=&quot;1-1什么是NoSQL&quot;&gt;&lt;a href=&quot;#1-1什么是NoSQL&quot; class=&quot;headerlink&quot; title=&quot;1.1	什么是NoSQL&quot;&gt;&lt;/a&gt;1.1	什么是NoSQL&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NoSQL最常见的解释是”&lt;code&gt;non-relational&lt;/code&gt;“， 很多人也说它是”&lt;em&gt;&lt;strong&gt;Not Only SQL&lt;/strong&gt;&lt;/em&gt;“&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NoSQL仅仅是一个概念，泛指&lt;strong&gt;非关系型的数据库&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区别于关系数据库，它们不保证关系数据的ACID特性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的NoSQL数据库有：&lt;code&gt;Redis&lt;/code&gt;、&lt;code&gt;MemCache&lt;/code&gt;、&lt;code&gt;MongoDB&lt;/code&gt;等&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、Redis入门"><a href="#一、Redis入门" class="headerlink" title="一、Redis入门"></a>一、Redis入门</h1><h2 id="1-认识NoSQL"><a href="#1-认识NoSQL" class="headerlink" title="1.认识NoSQL"></a>1.认识NoSQL</h2><h3 id="1-1什么是NoSQL"><a href="#1-1什么是NoSQL" class="headerlink" title="1.1什么是NoSQL"></a>1.1什么是NoSQL</h3><hr><ul><li><p>NoSQL最常见的解释是”<code>non-relational</code>“， 很多人也说它是”<em><strong>Not Only SQL</strong></em>“</p></li><li><p>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></p></li><li><p>区别于关系数据库，它们不保证关系数据的ACID特性</p></li><li><p>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</p></li><li><p>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</p><span id="more"></span></li></ul><h3 id="1-2NoSQL与SQL的差异"><a href="#1-2NoSQL与SQL的差异" class="headerlink" title="1.2NoSQL与SQL的差异"></a>1.2NoSQL与SQL的差异</h3><hr><table><thead><tr><th align="center"></th><th align="center">SQL</th><th align="center">NoSQL</th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">结构化</td><td align="center">非结构化</td></tr><tr><td align="center">数据关联</td><td align="center">关联的</td><td align="center">无关联的</td></tr><tr><td align="center">查询方式</td><td align="center">SQL查询</td><td align="center">非SQL</td></tr><tr><td align="center">事务特性</td><td align="center">ACID</td><td align="center">BASE</td></tr><tr><td align="center">存储方式</td><td align="center">磁盘</td><td align="center">内存</td></tr><tr><td align="center">扩展性</td><td align="center">垂直</td><td align="center">水平</td></tr><tr><td align="center">使用场景</td><td align="center">1）数据结构固定<br>2）相关业务对数据安全性、一致性要求较高</td><td align="center">1）数据结构不固定<br>2）对一致性、安全性要求不高<br>3）对性能要求</td></tr></tbody></table><h2 id="2-认识Redis"><a href="#2-认识Redis" class="headerlink" title="2.认识Redis"></a>2.认识Redis</h2><blockquote><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p></blockquote><p><strong>Redis的特征：</strong></p><ul><li>键值（<code>key-value</code>）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="3-安装Redis"><a href="#3-安装Redis" class="headerlink" title="3.安装Redis"></a>3.安装Redis</h2><h3 id="3-1前置准备"><a href="#3-1前置准备" class="headerlink" title="3.1前置准备"></a>3.1前置准备</h3><hr><blockquote><p>本次安装Redis是基于Linux系统下安装的，因此需要一台Linux服务器或者虚拟机。</p><p>Ps：由于提供的CentOS操作系统为mini版，因此需要自行配置网络，不会配置的请联系我，如果您使用的是自己购买的服务器，请提前开放<code>6379</code>端口，避免后续出现的莫名其妙的错误！</p></blockquote><ul><li><p><strong>虚拟机</strong>：<a href="https://pan.baidu.com/s/1Zn13h9G7MtSgz-xdkQFeJg?pwd=1234">VMware16</a></p></li><li><p><strong>操作系统</strong>：<a href="https://pan.baidu.com/s/1SiYip29cYqiNBqjGGV0JgA?pwd=1234">CentOS-7-x86_64-Minimal-1708</a></p></li><li><p><strong>Redis</strong>：<a href="https://pan.baidu.com/s/1hsoEz1NTCDCCWZmaiZrIgg?pwd=1234">redis-6.2.6.tar</a></p></li><li><p><strong>xShell及xFtp</strong>：<a href="https://www.xshell.com/zh/free-for-home-school/">https://www.xshell.com/zh/free-for-home-school/</a></p></li></ul><h3 id="3-2安装Redis依赖"><a href="#3-2安装Redis依赖" class="headerlink" title="3.2安装Redis依赖"></a>3.2安装Redis依赖</h3><hr><blockquote><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p><strong>安装成功如下图所示：</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-5.png" alt="image-20220524181842626"></p><h3 id="3-3正式安装Redis"><a href="#3-3正式安装Redis" class="headerlink" title="3.3正式安装Redis"></a>3.3正式安装Redis</h3><hr><ul><li><p><strong>将<code>redis-6.2.6.tar</code>上传至<code>/usr/local/src</code>目录</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-4.png" alt="image-20220524185659727"></p></li><li><p><strong>在xShell中<code>cd</code>到<code>/usr/local/src</code>目录执行以下命令进行解压操作</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure></li><li><p><strong>解压成功后依次执行以下命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p><strong>安装成功后打开&#x2F;usr&#x2F;local&#x2F;bin目录（该目录为Redis默认的安装目录）</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-3.png" alt="image-20220524190400547"></p></li></ul><h2 id="4-启动Redis"><a href="#4-启动Redis" class="headerlink" title="4.启动Redis"></a>4.启动Redis</h2><blockquote><p>Redis的启动方式有很多种，例如：<strong>前台启动</strong>、<strong>后台启动</strong>、<strong>开机自启</strong></p></blockquote><h3 id="4-1前台启动（不推荐）"><a href="#4-1前台启动（不推荐）" class="headerlink" title="4.1前台启动（不推荐）"></a>4.1前台启动（不推荐）</h3><hr><blockquote><p><strong>这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</strong></p></blockquote><ul><li><p><strong>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure></li><li><p><strong>启动成功如下图所示</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-2.png" alt="image-20220524191137983"></p></li></ul><h3 id="4-2后台启动（不推荐）"><a href="#4-2后台启动（不推荐）" class="headerlink" title="4.2后台启动（不推荐）"></a>4.2后台启动（不推荐）</h3><hr><blockquote><p><strong>如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下</strong></p></blockquote><ul><li><p><strong>因为我们要修改配置文件，因此我们需要先将原文件备份一份</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure></li><li><p><strong>然后修改<code>redis.conf</code>文件中的一些配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span> </span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass 1325</span><br></pre></td></tr></table></figure></li><li><p><strong>Redis其他常用配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="built_in">dir</span> .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>停止Redis服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过kill命令直接杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 redis进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -a 来指定密码</span></span><br><span class="line">redis-cli -a 132537 shutdown</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3开机自启（推荐）"><a href="#4-3开机自启（推荐）" class="headerlink" title="4.3开机自启（推荐）"></a>4.3开机自启（推荐）</h3><hr><blockquote><p><strong>我们也可以通过配置来实现开机自启</strong></p></blockquote><ul><li><p><strong>首先，新建一个系统服务文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure></li><li><p><strong>将以下命令粘贴进去</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p><strong>然后重载系统服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p><strong>现在，我们可以用下面这组命令来操作redis了</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li><li><p><strong>执行下面的命令，可以让redis开机自启</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure></li></ul><h1 id="二、Redis常见命令"><a href="#二、Redis常见命令" class="headerlink" title="二、Redis常见命令"></a>二、Redis常见命令</h1><blockquote><p>我们可以通过Redis的中文文档：<a href="http://www.redis.cn/commands.html%EF%BC%8C%E6%9D%A5%E5%AD%A6%E4%B9%A0%E5%90%84%E7%A7%8D%E5%91%BD%E4%BB%A4%E3%80%82">http://www.redis.cn/commands.html，来学习各种命令。</a></p><p>也可以通过菜鸟教程官网来学习：<a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></p></blockquote><h2 id="1-Redis数据结构介绍"><a href="#1-Redis数据结构介绍" class="headerlink" title="1.Redis数据结构介绍"></a>1.Redis数据结构介绍</h2><blockquote><p><strong>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</strong></p></blockquote><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis01.png" alt="image-20220524205926164"></p><h2 id="2-通用命令"><a href="#2-通用命令" class="headerlink" title="2.通用命令"></a>2.通用命令</h2><blockquote><p><strong>通用指令是部分数据类型的，都可以使用的指令，常见的有如下表格所示</strong></p></blockquote><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">KEYS</td><td align="center">查看符合模板的所有key，不建议在生产环境设备上使用</td></tr><tr><td align="center">DEL</td><td align="center">删除一个指定的key</td></tr><tr><td align="center">EXISTS</td><td align="center">判断key是否存在</td></tr><tr><td align="center">EXPIRE</td><td align="center">给一个key设置有效期，有效期到期时该key会被自动删除</td></tr><tr><td align="center">TTL</td><td align="center">查看一个KEY的剩余有效期</td></tr></tbody></table><p><strong>可以通过<code>help [command] </code>可以查看一个命令的具体用法！</strong></p><h2 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3.String类型"></a>3.String类型</h2><blockquote><p><strong>String类型，也就是字符串类型，是Redis中最简单的存储类型。</strong></p></blockquote><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><blockquote><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过<strong>512m</strong>.</p></blockquote><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">msg</td><td align="center">hello world</td></tr><tr><td align="center">num</td><td align="center">10</td></tr><tr><td align="center">score</td><td align="center">92.5</td></tr></tbody></table><blockquote><p><strong>String的常见命令有如下表格所示</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SET</td><td align="center">添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td align="center">GET</td><td align="center">根据key获取String类型的value</td></tr><tr><td align="center">MSET</td><td align="center">批量添加多个String类型的键值对</td></tr><tr><td align="center">MGET</td><td align="center">根据多个key获取多个String类型的value</td></tr><tr><td align="center">INCR</td><td align="center">让一个整型的key自增1</td></tr><tr><td align="center">INCRBY</td><td align="center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td align="center">INCRBYFLOAT</td><td align="center">让一个浮点类型的数字自增并指定步长</td></tr><tr><td align="center">SETNX</td><td align="center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td align="center"><strong>SETEX</strong></td><td align="center">添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table><blockquote><p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 <code>heima</code>，有<code>user</code>和<code>product</code>两种不同类型的数据，我们可以这样定义key：</p><ul><li><strong>user</strong>相关的key：<code>heima:user:1</code></li><li><strong>product</strong>相关的key：<code>heima:product:1</code></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">heima:user:1</td><td align="center">{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td align="center">heima:product:1</td><td align="center">{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h2 id="4-Hash类型"><a href="#4-Hash类型" class="headerlink" title="4.Hash类型"></a>4.Hash类型</h2><blockquote><p><strong>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的<code>HashMap</code>结构。</strong></p></blockquote><ul><li><p><strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525001227167.png" alt="image-20220525001227167"  /></li><li><p><strong>Hash的常见命令有：</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">HSET key field value</td><td align="center">添加或者修改hash类型key的field的值</td></tr><tr><td align="center">HGET key field</td><td align="center">获取一个hash类型key的field的值</td></tr><tr><td align="center">HMSET</td><td align="center">hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td></tr><tr><td align="center">HMGET</td><td align="center">批量获取多个hash类型key的field的值</td></tr><tr><td align="center">HGETALL</td><td align="center">获取一个hash类型的key中的所有的field和value</td></tr><tr><td align="center">HKEYS</td><td align="center">获取一个hash类型的key中的所有的field</td></tr><tr><td align="center">HVALS</td><td align="center">获取一个hash类型的key中的所有的value</td></tr><tr><td align="center">HINCRBY</td><td align="center">让一个hash类型key的字段值自增并指定步长</td></tr><tr><td align="center">HSETNX</td><td align="center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr></tbody></table></li></ul><h2 id="5-List类型"><a href="#5-List类型" class="headerlink" title="5.List类型"></a>5.List类型</h2><blockquote><p><strong>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p></blockquote><p><strong>特征也与<code>LinkedList</code>类似：</strong></p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.</p><blockquote><p><strong>List的常见命令有</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">LPUSH key  element …</td><td align="center">向列表左侧插入一个或多个元素</td></tr><tr><td align="center">LPOP key</td><td align="center">移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td align="center"><strong>RPUSH key  element …</strong></td><td align="center">向列表右侧插入一个或多个元素</td></tr><tr><td align="center">RPOP key</td><td align="center">移除并返回列表右侧的第一个元素</td></tr><tr><td align="center">LRANGE key star end</td><td align="center">返回一段角标范围内的所有元素</td></tr><tr><td align="center">BLPOP和BRPOP</td><td align="center">与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr></tbody></table><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/new.gif" alt="new"></p><blockquote><p><strong>思考问题</strong></p></blockquote><ul><li><p><strong>如何利用List结构模拟一个栈?</strong></p><ul><li>先进后出，入口和出口在同一边</li></ul></li><li><p><strong>如何利用List结构模拟一个队列?</strong></p><ul><li>先进先出，入口和出口在不同边</li></ul></li><li><p><strong>如何利用List结构模拟一个阻塞队列?</strong></p><ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul></li></ul><h2 id="6-Set类型"><a href="#6-Set类型" class="headerlink" title="6.Set类型"></a>6.Set类型</h2><blockquote><p><strong>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征</strong></p></blockquote><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><blockquote><p><strong>Set的常见命令有</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SADD key member …</td><td align="center">向set中添加一个或多个元素</td></tr><tr><td align="center">SREM key member …</td><td align="center">移除set中的指定元素</td></tr><tr><td align="center">SCARD key</td><td align="center">返回set中元素的个数</td></tr><tr><td align="center">SISMEMBER key member</td><td align="center">判断一个元素是否存在于set中</td></tr><tr><td align="center">SMEMBERS</td><td align="center">获取set中的所有元素</td></tr><tr><td align="center">SINTER key1 key2 …</td><td align="center">求key1与key2的交集</td></tr><tr><td align="center">SDIFF key1 key2 …</td><td align="center">求key1与key2的差集</td></tr><tr><td align="center">SUNION key1 key2 ..</td><td align="center">求key1和key2的并集</td></tr></tbody></table><blockquote><p><strong>交集、差集、并集图示</strong></p></blockquote><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-6.png" alt="image-20220525112632214"></p><h2 id="7-SortedSet类型"><a href="#7-SortedSet类型" class="headerlink" title="7.SortedSet类型"></a>7.SortedSet类型</h2><blockquote><p><strong>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</strong></p></blockquote><p><strong>SortedSet具备下列特性：</strong></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><blockquote><p><strong>SortedSet的常见命令有</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ZADD key score member</td><td align="center">添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td align="center">ZREM key member</td><td align="center">删除sorted set中的一个指定元素</td></tr><tr><td align="center">ZSCORE key member</td><td align="center">获取sorted set中的指定元素的score值</td></tr><tr><td align="center">ZRANK key member</td><td align="center">获取sorted set 中的指定元素的排名</td></tr><tr><td align="center">ZCARD key</td><td align="center">获取sorted set中的元素个数</td></tr><tr><td align="center">ZCOUNT key min max</td><td align="center">统计score值在给定范围内的所有元素的个数</td></tr><tr><td align="center">ZINCRBY key increment member</td><td align="center">让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td align="center">ZRANGE key min max</td><td align="center">按照score排序后，获取指定排名范围内的元素</td></tr><tr><td align="center">ZRANGEBYSCORE key min max</td><td align="center">按照score排序后，获取指定score范围内的元素</td></tr><tr><td align="center">ZDIFF、ZINTER、ZUNION</td><td align="center">求差集、交集、并集</td></tr></tbody></table><p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加<code>REV</code>即可</strong></p><h1 id="三、Redis客户端"><a href="#三、Redis客户端" class="headerlink" title="三、Redis客户端"></a>三、Redis客户端</h1><blockquote><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p></blockquote><ul><li><strong>命令行客户端</strong></li><li><strong>图形化桌面客户端</strong></li><li><strong>编程客户端</strong></li></ul><h2 id="1-命令行客户端"><a href="#1-命令行客户端" class="headerlink" title="1.命令行客户端"></a>1.命令行客户端</h2><ul><li><p><strong>Redis安装完成后就自带了命令行客户端：<code>redis-cli</code>，使用方式如下：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure></li><li><p><strong>其中常见的<code>options</code>有：</strong></p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 132537</code>：指定redis的访问密码</li></ul></li><li><p><strong>其中的<code>commonds</code>就是Redis的操作命令，例如：</strong></p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li><li>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</li></ul></li></ul><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-7.png" alt="image-20220524201258092"></p><h2 id="2-图形化客户端"><a href="#2-图形化客户端" class="headerlink" title="2.图形化客户端"></a>2.图形化客户端</h2><blockquote><p>下载地址：<a href="https://pan.baidu.com/s/1sxQTOt-A5MCvVZnlgDf0eA?pwd=1234">https://pan.baidu.com/s/1sxQTOt-A5MCvVZnlgDf0eA?pwd=1234</a> </p></blockquote><ul><li><p><strong>安装图形化客户端</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装步骤过于简单不再演示</span><br></pre></td></tr></table></figure></li><li><p><strong>如何连接到Redis</strong></p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-8.png" alt="image-20220524202853286" style="zoom:80%;" /></li><li><p><strong>连接成功后如图所示</strong></p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-9.png" alt="image-20220524203745436" style="zoom:80%;" /></li></ul><h2 id="3-Java客户端"><a href="#3-Java客户端" class="headerlink" title="3.Java客户端"></a>3.Java客户端</h2><h3 id="3-1Jedis快速入门"><a href="#3-1Jedis快速入门" class="headerlink" title="3.1Jedis快速入门"></a>3.1Jedis快速入门</h3><hr><blockquote><p>Jedis的官网地址： <a href="https://github.com/redis/jedis%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A">https://github.com/redis/jedis，我们先来个快速入门：</a></p></blockquote><ul><li><p><strong>新建一个Maven工程并引入以下依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Jedis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入单元测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试类并与Redis建立连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span> <span class="comment">//被该注解修饰的方法每次执行其他方法前自动执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取连接</span></span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.230.88&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 2. 设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;132537&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 选择库（默认是下标为0的库）</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写一个操作数据的方法（这里以操作String类型为例）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.往redis中存放一条String类型的数据并获取返回结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;https://www.oz6.cn&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从redis中获取一条数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;url = &quot;</span> + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后不要忘记编写一个释放资源的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span> <span class="comment">//被该注解修饰的方法会在每次执行其他方法后执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行<code>testString()</code>方法后测试结果如图所示</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-10.png" alt="image-20220525131017888"></p></li></ul><h3 id="3-2Jedis连接池"><a href="#3-2Jedis连接池" class="headerlink" title="3.2Jedis连接池"></a>3.2Jedis连接池</h3><hr><blockquote><p><strong>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,<span class="string">&quot;192.168.230.88&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;132537&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3SpringDataRedis介绍"><a href="#3-3SpringDataRedis介绍" class="headerlink" title="3.3SpringDataRedis介绍"></a>3.3SpringDataRedis介绍</h3><hr><blockquote><p><strong>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做<code>SpringDataRedis</code></strong></p><p><strong>官网地址</strong>：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p></blockquote><ul><li>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</li><li>提供了<code>RedisTemplate</code>统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><blockquote><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p></blockquote><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis11.png" alt="image-20220525140217446"></p><h3 id="3-4-SpringDataRedis快速入门"><a href="#3-4-SpringDataRedis快速入门" class="headerlink" title="3.4 SpringDataRedis快速入门"></a>3.4 SpringDataRedis快速入门</h3><hr><blockquote><p><strong><code>SpringBoot</code>已经提供了对<code>SpringDataRedis</code>的支持，使用非常简单</strong></p></blockquote><ul><li><p><strong>首先新建一个Spring Boot工程</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-12.png" alt="image-20220525141608974"></p></li><li><p><strong>然后引入连接池依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写配置文件<code>application.yml</code>（连接池的配置在实际开发中是根据需求来的）</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.230</span><span class="number">.88</span> <span class="comment">#指定redis所在的host</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span>  <span class="comment">#指定redis的端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span>  <span class="comment">#设置redis密码</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试类执行测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1.通过RedisTemplate获取操作String类型的ValueOperations对象</span></span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">ops</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"><span class="comment">// 2.插入一条数据</span></span><br><span class="line">ops.set(<span class="string">&quot;blogName&quot;</span>,<span class="string">&quot;Vz-Blog&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">blogName</span> <span class="operator">=</span> (String) ops.get(<span class="string">&quot;blogName&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;blogName = &quot;</span> + blogName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5RedisSerializer配置"><a href="#3-5RedisSerializer配置" class="headerlink" title="3.5RedisSerializer配置"></a>3.5RedisSerializer配置</h3><hr><blockquote><p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果是这样的</strong></p></blockquote><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-13.png" alt="image-20220525170205272"></p><p><strong>缺点：</strong></p><ul><li>可读性差</li><li>内存占用较大</li></ul><blockquote><p><strong>那么如何解决以上的问题呢？我们可以通过自定义RedisTemplate序列化的方式来解决。</strong></p></blockquote><ul><li><p><strong>编写一个配置类<code>RedisConfig</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String ,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2.设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建序列化对象</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置key和hashKey采用String的序列化方式</span></span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.设置value和hashValue采用json的序列化方式</span></span><br><span class="line">        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>此时我们已经将RedisTemplate的key设置为<code>String序列化</code>，value设置为<code>Json序列化</code>的方式，再来执行方法测试</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-14.png" alt="image-20220525170925364"></p></li><li><p><strong>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-15.png" alt="image-20220525171340322"></p><p>尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。</p><p>如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>那么我们如何解决这个问题呢？我们可以通过下文的<code>StringRedisTemplate</code>来解决这个问题。</p></li></ul><h3 id="3-6StringRedisTemplate"><a href="#3-6StringRedisTemplate" class="headerlink" title="3.6StringRedisTemplate"></a>3.6StringRedisTemplate</h3><hr><blockquote><p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p></blockquote><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-16.png" alt="image-20220525172001057"></p><blockquote><p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p></blockquote><ul><li><p><strong>我们可以直接编写一个测试类使用StringRedisTemplate来执行以下方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTemplateTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"><span class="comment">// 1.创建一个Json序列化对象</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 2.将要存入的对象通过Json序列化对象转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson1</span> <span class="operator">=</span> objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line"><span class="comment">// 3.通过StringRedisTemplate将数据存入redis</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,userJson1);</span><br><span class="line"><span class="comment">// 4.通过key取出value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line"><span class="comment">// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(userJson2, User.class);</span><br><span class="line"><span class="comment">// 6.打印结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行完毕回到Redis的图形化客户端查看结果</strong></p><p><img src="https://fmphoto.oss-cn-chengdu.aliyuncs.com/Photo/redis-17.png" alt="image-20220525172508234"></p></li></ul><h3 id="3-7总结"><a href="#3-7总结" class="headerlink" title="3.7总结"></a>3.7总结</h3><hr><blockquote><p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p></blockquote><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      <category domain="http://example.com/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/2023/redis-ji-chu-pian/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
